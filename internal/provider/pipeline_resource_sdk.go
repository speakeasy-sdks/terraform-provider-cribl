// Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.

package provider

import (
	"Cribl/internal/sdk/pkg/models/shared"
	"github.com/hashicorp/terraform-plugin-framework/types"
)

func (r *PipelineResourceModel) ToCreateSDKType() *shared.Pipeline {
	asyncFuncTimeout := new(int64)
	if !r.Conf.AsyncFuncTimeout.IsUnknown() && !r.Conf.AsyncFuncTimeout.IsNull() {
		*asyncFuncTimeout = r.Conf.AsyncFuncTimeout.ValueInt64()
	} else {
		asyncFuncTimeout = nil
	}
	description := new(string)
	if !r.Conf.Description.IsUnknown() && !r.Conf.Description.IsNull() {
		*description = r.Conf.Description.ValueString()
	} else {
		description = nil
	}
	var functions []shared.PipelineFunctionConf = nil
	for _, functionsItem := range r.Conf.Functions {
		conf1 := shared.PipelineFunctionConfFunctionSpecificConfigs{}
		description1 := new(string)
		if !functionsItem.Description.IsUnknown() && !functionsItem.Description.IsNull() {
			*description1 = functionsItem.Description.ValueString()
		} else {
			description1 = nil
		}
		disabled := new(bool)
		if !functionsItem.Disabled.IsUnknown() && !functionsItem.Disabled.IsNull() {
			*disabled = functionsItem.Disabled.ValueBool()
		} else {
			disabled = nil
		}
		filter := new(string)
		if !functionsItem.Filter.IsUnknown() && !functionsItem.Filter.IsNull() {
			*filter = functionsItem.Filter.ValueString()
		} else {
			filter = nil
		}
		final := new(bool)
		if !functionsItem.Final.IsUnknown() && !functionsItem.Final.IsNull() {
			*final = functionsItem.Final.ValueBool()
		} else {
			final = nil
		}
		groupID := new(string)
		if !functionsItem.GroupID.IsUnknown() && !functionsItem.GroupID.IsNull() {
			*groupID = functionsItem.GroupID.ValueString()
		} else {
			groupID = nil
		}
		id := functionsItem.ID.ValueString()
		functions = append(functions, shared.PipelineFunctionConf{
			Conf:        conf1,
			Description: description1,
			Disabled:    disabled,
			Filter:      filter,
			Final:       final,
			GroupID:     groupID,
			ID:          id,
		})
	}
	groups := make(map[string]shared.PipelineConfGroups)
	for groupsKey, groupsValue := range r.Conf.Groups {
		description2 := new(string)
		if !groupsValue.Description.IsUnknown() && !groupsValue.Description.IsNull() {
			*description2 = groupsValue.Description.ValueString()
		} else {
			description2 = nil
		}
		disabled1 := new(bool)
		if !groupsValue.Disabled.IsUnknown() && !groupsValue.Disabled.IsNull() {
			*disabled1 = groupsValue.Disabled.ValueBool()
		} else {
			disabled1 = nil
		}
		name := groupsValue.Name.ValueString()
		groupsInst := shared.PipelineConfGroups{
			Description: description2,
			Disabled:    disabled1,
			Name:        name,
		}
		groups[groupsKey] = groupsInst
	}
	output := new(string)
	if !r.Conf.Output.IsUnknown() && !r.Conf.Output.IsNull() {
		*output = r.Conf.Output.ValueString()
	} else {
		output = nil
	}
	var streamtags []string = nil
	for _, streamtagsItem := range r.Conf.Streamtags {
		streamtags = append(streamtags, streamtagsItem.ValueString())
	}
	conf := shared.PipelineConf{
		AsyncFuncTimeout: asyncFuncTimeout,
		Description:      description,
		Functions:        functions,
		Groups:           groups,
		Output:           output,
		Streamtags:       streamtags,
	}
	id1 := r.ID.ValueString()
	out := shared.Pipeline{
		Conf: conf,
		ID:   id1,
	}
	return &out
}

func (r *PipelineResourceModel) ToGetSDKType() *shared.Pipeline {
	out := r.ToCreateSDKType()
	return out
}

func (r *PipelineResourceModel) ToUpdateSDKType() *shared.Pipeline {
	out := r.ToCreateSDKType()
	return out
}

func (r *PipelineResourceModel) ToDeleteSDKType() *shared.Pipeline {
	out := r.ToCreateSDKType()
	return out
}

func (r *PipelineResourceModel) RefreshFromGetResponse(resp *shared.Error) {
	if resp.Message != nil {
		r.Message = types.StringValue(*resp.Message)
	} else {
		r.Message = types.StringNull()
	}
}

func (r *PipelineResourceModel) RefreshFromCreateResponse(resp *shared.Error) {
	r.RefreshFromGetResponse(resp)
}

func (r *PipelineResourceModel) RefreshFromUpdateResponse(resp *shared.Error) {
	r.RefreshFromGetResponse(resp)
}
