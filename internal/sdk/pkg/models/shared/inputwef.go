// Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.

package shared

import (
	"encoding/json"
	"fmt"
)

// InputWefAuthenticationMethod - Method by which to authenticate incoming client connections.
type InputWefAuthenticationMethod string

const (
	InputWefAuthenticationMethodKerberos   InputWefAuthenticationMethod = "kerberos"
	InputWefAuthenticationMethodClientCert InputWefAuthenticationMethod = "clientCert"
)

func (e InputWefAuthenticationMethod) ToPointer() *InputWefAuthenticationMethod {
	return &e
}

func (e *InputWefAuthenticationMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "kerberos":
		fallthrough
	case "clientCert":
		*e = InputWefAuthenticationMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for InputWefAuthenticationMethod: %v", v)
	}
}

type InputWefConnections struct {
	// Select a Destination.
	Output string `json:"output"`
	// Select Pipeline or Pack. Optional.
	Pipeline *string `json:"pipeline,omitempty"`
}

type InputWefOptionalFieldsInGeneralSection string

const (
	InputWefOptionalFieldsInGeneralSectionAuthMethod InputWefOptionalFieldsInGeneralSection = "authMethod"
	InputWefOptionalFieldsInGeneralSectionKeytab     InputWefOptionalFieldsInGeneralSection = "keytab"
)

func (e InputWefOptionalFieldsInGeneralSection) ToPointer() *InputWefOptionalFieldsInGeneralSection {
	return &e
}

func (e *InputWefOptionalFieldsInGeneralSection) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "authMethod":
		fallthrough
	case "keytab":
		*e = InputWefOptionalFieldsInGeneralSection(v)
		return nil
	default:
		return fmt.Errorf("invalid value for InputWefOptionalFieldsInGeneralSection: %v", v)
	}
}

// InputWefPqCompression - Codec to use to compress the persisted data.
type InputWefPqCompression string

const (
	InputWefPqCompressionNone InputWefPqCompression = "none"
	InputWefPqCompressionGzip InputWefPqCompression = "gzip"
)

func (e InputWefPqCompression) ToPointer() *InputWefPqCompression {
	return &e
}

func (e *InputWefPqCompression) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "none":
		fallthrough
	case "gzip":
		*e = InputWefPqCompression(v)
		return nil
	default:
		return fmt.Errorf("invalid value for InputWefPqCompression: %v", v)
	}
}

// InputWefPqMode - With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
type InputWefPqMode string

const (
	InputWefPqModeSmart  InputWefPqMode = "smart"
	InputWefPqModeAlways InputWefPqMode = "always"
)

func (e InputWefPqMode) ToPointer() *InputWefPqMode {
	return &e
}

func (e *InputWefPqMode) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "smart":
		fallthrough
	case "always":
		*e = InputWefPqMode(v)
		return nil
	default:
		return fmt.Errorf("invalid value for InputWefPqMode: %v", v)
	}
}

type InputWefPq struct {
	// The number of events to send downstream before committing that Stream has read them.
	CommitFrequency *int64 `json:"commitFrequency,omitempty"`
	// Codec to use to compress the persisted data.
	Compress *InputWefPqCompression `json:"compress,omitempty"`
	// The maximum number of events to hold in memory before writing the events to disk.
	MaxBufferSize *int64 `json:"maxBufferSize,omitempty"`
	// The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.).
	MaxFileSize *string `json:"maxFileSize,omitempty"`
	// The maximum amount of disk space the queue is allowed to consume. Once reached, the system stops queueing and applies the fallback Queue-full behavior. Enter a numeral with units of KB, MB, etc.
	MaxSize *string `json:"maxSize,omitempty"`
	// With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
	Mode *InputWefPqMode `json:"mode,omitempty"`
	// The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>.
	Path *string `json:"path,omitempty"`
}

// InputWefSubscriptionsFormat - Content format in which the endpoint should deliver events.
type InputWefSubscriptionsFormat string

const (
	InputWefSubscriptionsFormatRaw          InputWefSubscriptionsFormat = "Raw"
	InputWefSubscriptionsFormatRenderedText InputWefSubscriptionsFormat = "RenderedText"
)

func (e InputWefSubscriptionsFormat) ToPointer() *InputWefSubscriptionsFormat {
	return &e
}

func (e *InputWefSubscriptionsFormat) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "Raw":
		fallthrough
	case "RenderedText":
		*e = InputWefSubscriptionsFormat(v)
		return nil
	default:
		return fmt.Errorf("invalid value for InputWefSubscriptionsFormat: %v", v)
	}
}

// InputWefSubscriptionsQueryBuilderMode - Select the query builder mode.
type InputWefSubscriptionsQueryBuilderMode string

const (
	InputWefSubscriptionsQueryBuilderModeSimple InputWefSubscriptionsQueryBuilderMode = "simple"
	InputWefSubscriptionsQueryBuilderModeXML    InputWefSubscriptionsQueryBuilderMode = "xml"
)

func (e InputWefSubscriptionsQueryBuilderMode) ToPointer() *InputWefSubscriptionsQueryBuilderMode {
	return &e
}

func (e *InputWefSubscriptionsQueryBuilderMode) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "simple":
		fallthrough
	case "xml":
		*e = InputWefSubscriptionsQueryBuilderMode(v)
		return nil
	default:
		return fmt.Errorf("invalid value for InputWefSubscriptionsQueryBuilderMode: %v", v)
	}
}

type InputWefSubscriptions struct {
	// Interval (in seconds) over which the endpoint should collect events before sending them to Stream.
	BatchTimeout int64 `json:"batchTimeout"`
	// If toggled to Yes, Stream will receive compressed events from the source.
	Compress *bool `json:"compress,omitempty"`
	// Content format in which the endpoint should deliver events.
	ContentFormat InputWefSubscriptionsFormat `json:"contentFormat"`
	// Max time (in seconds) between endpoint checkins before considering it unavailable.
	HeartbeatInterval int64 `json:"heartbeatInterval"`
	// Select the query builder mode.
	QuerySelector *InputWefSubscriptionsQueryBuilderMode `json:"querySelector,omitempty"`
	// Set to Yes if a newly-subscribed endpoint should send previously existing events. Set to No to only receive new events
	ReadExistingEvents *bool `json:"readExistingEvents,omitempty"`
	// If toggled to Yes, @{product} will keep track of which events have been received, resuming from that point after a re-subscription. This setting takes precedence over 'Read existing events' -- see the documentation for details.
	SendBookmarks *bool `json:"sendBookmarks,omitempty"`
	// Friendly name for this subscription.
	SubscriptionName string `json:"subscriptionName"`
	// Enter the DNS names of the endpoints that should forward these events. You may use wildcards, for example: *.mydomain.com
	Targets []string `json:"targets"`
	// Version UUID for this subscription. If any subscription parameters are modified, this value will change.
	Version *string `json:"version,omitempty"`
}

// InputWefMTLSSettingsMaximumTLSVersion - Maximum TLS version to accept from connections
type InputWefMTLSSettingsMaximumTLSVersion string

const (
	InputWefMTLSSettingsMaximumTLSVersionTlSv1  InputWefMTLSSettingsMaximumTLSVersion = "TLSv1"
	InputWefMTLSSettingsMaximumTLSVersionTlSv11 InputWefMTLSSettingsMaximumTLSVersion = "TLSv1.1"
	InputWefMTLSSettingsMaximumTLSVersionTlSv12 InputWefMTLSSettingsMaximumTLSVersion = "TLSv1.2"
	InputWefMTLSSettingsMaximumTLSVersionTlSv13 InputWefMTLSSettingsMaximumTLSVersion = "TLSv1.3"
)

func (e InputWefMTLSSettingsMaximumTLSVersion) ToPointer() *InputWefMTLSSettingsMaximumTLSVersion {
	return &e
}

func (e *InputWefMTLSSettingsMaximumTLSVersion) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "TLSv1":
		fallthrough
	case "TLSv1.1":
		fallthrough
	case "TLSv1.2":
		fallthrough
	case "TLSv1.3":
		*e = InputWefMTLSSettingsMaximumTLSVersion(v)
		return nil
	default:
		return fmt.Errorf("invalid value for InputWefMTLSSettingsMaximumTLSVersion: %v", v)
	}
}

// InputWefMTLSSettingsMinimumTLSVersion - Minimum TLS version to accept from connections.
type InputWefMTLSSettingsMinimumTLSVersion string

const (
	InputWefMTLSSettingsMinimumTLSVersionTlSv1  InputWefMTLSSettingsMinimumTLSVersion = "TLSv1"
	InputWefMTLSSettingsMinimumTLSVersionTlSv11 InputWefMTLSSettingsMinimumTLSVersion = "TLSv1.1"
	InputWefMTLSSettingsMinimumTLSVersionTlSv12 InputWefMTLSSettingsMinimumTLSVersion = "TLSv1.2"
	InputWefMTLSSettingsMinimumTLSVersionTlSv13 InputWefMTLSSettingsMinimumTLSVersion = "TLSv1.3"
)

func (e InputWefMTLSSettingsMinimumTLSVersion) ToPointer() *InputWefMTLSSettingsMinimumTLSVersion {
	return &e
}

func (e *InputWefMTLSSettingsMinimumTLSVersion) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "TLSv1":
		fallthrough
	case "TLSv1.1":
		fallthrough
	case "TLSv1.2":
		fallthrough
	case "TLSv1.3":
		*e = InputWefMTLSSettingsMinimumTLSVersion(v)
		return nil
	default:
		return fmt.Errorf("invalid value for InputWefMTLSSettingsMinimumTLSVersion: %v", v)
	}
}

type InputWefMTLSSettings struct {
	// Server path containing CA certificates (in PEM format) to use. Can reference $ENV_VARS. If multiple certificates are present in a .pem, each must directly certify the one preceding it.
	CaPath string `json:"caPath"`
	// Path on server containing certificates to use. PEM format. Can reference $ENV_VARS.
	CertPath string `json:"certPath"`
	// Name of the predefined certificate.
	CertificateName *string `json:"certificateName,omitempty"`
	// Regex matching allowable common names in peer certificates' subject attribute.
	CommonNameRegex *string `json:"commonNameRegex,omitempty"`
	// Enable TLS
	Disabled *bool       `json:"disabled,omitempty"`
	Keytab   interface{} `json:"keytab,omitempty"`
	// Maximum TLS version to accept from connections
	MaxVersion *InputWefMTLSSettingsMaximumTLSVersion `json:"maxVersion,omitempty"`
	// Minimum TLS version to accept from connections.
	MinVersion *InputWefMTLSSettingsMinimumTLSVersion `json:"minVersion,omitempty"`
	// Enable OCSP check of certificate
	OcspCheck *bool `json:"ocspCheck,omitempty"`
	// If enabled, checks will fail on any OCSP error. Otherwise, checks will fail only when a certificate is revoked, ignoring other errors.
	OcspCheckFailClose *bool `json:"ocspCheckFailClose,omitempty"`
	// Passphrase to use to decrypt private key.
	Passphrase *string     `json:"passphrase,omitempty"`
	Principal  interface{} `json:"principal,omitempty"`
	// Path on server containing the private key to use. PEM format. Can reference $ENV_VARS.
	PrivKeyPath string `json:"privKeyPath"`
	// Required for WEF certificate authentication.
	RejectUnauthorized *bool `json:"rejectUnauthorized,omitempty"`
	// Required for WEF certificate authentication.
	RequestCert *bool `json:"requestCert,omitempty"`
}

type InputWefType string

const (
	InputWefTypeWef InputWefType = "wef"
)

func (e InputWefType) ToPointer() *InputWefType {
	return &e
}

func (e *InputWefType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "wef":
		*e = InputWefType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for InputWefType: %v", v)
	}
}

type InputWef struct {
	// Allow events to be ingested even if their MachineID does not match the client certificate CN.
	AllowMachineIDMismatch *bool `json:"allowMachineIdMismatch,omitempty"`
	// Method by which to authenticate incoming client connections.
	AuthMethod *InputWefAuthenticationMethod `json:"authMethod,omitempty"`
	// SHA1 fingerprint expected by the client, if it does not match the first certificate in the configured CA chain
	CaFingerprint *string `json:"caFingerprint,omitempty"`
	// Toggle this to Yes to add request headers to events, in the __headers field.
	CaptureHeaders *bool `json:"captureHeaders,omitempty"`
	// Direct connections to Destinations, optionally via a Pipeline or a Pack.
	Connections []InputWefConnections `json:"connections,omitempty"`
	// Enable/disable this input
	Disabled *bool `json:"disabled,omitempty"`
	// Enable if the connection is proxied by a device that supports Proxy Protocol V1 or V2.
	EnableProxyHeader *bool `json:"enableProxyHeader,omitempty"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Address to bind on. Defaults to 0.0.0.0 (all addresses).
	Host string `json:"host"`
	// Unique ID for this input
	ID *string `json:"id,omitempty"`
	// After the last response is sent, @{product} will wait this long for additional data before closing the socket connection. Minimum 1 sec.; maximum 600 sec. (10 min.).
	KeepAliveTimeout *int64 `json:"keepAliveTimeout,omitempty"`
	// Path to the keytab file containing the service principal credentials. @{product} will use `/etc/krb5.keytab` if not provided.
	Keytab *string `json:"keytab,omitempty"`
	// Maximum number of active requests per Worker Process. Use 0 for unlimited.
	MaxActiveReq                   *int64                                  `json:"maxActiveReq,omitempty"`
	OptionalFieldsInGeneralSection *InputWefOptionalFieldsInGeneralSection `json:"optionalFieldsInGeneralSection,omitempty"`
	// Pipeline to process data from this Source before sending it through the Routes.
	Pipeline *string `json:"pipeline,omitempty"`
	// Port to listen on.
	Port int64       `json:"port"`
	Pq   *InputWefPq `json:"pq,omitempty"`
	// For details on Persistent Queues, see: [https://docs.cribl.io/stream/persistent-queues](https://docs.cribl.io/stream/persistent-queues)
	PqEnabled *bool `json:"pqEnabled,omitempty"`
	// Kerberos principal used for authentication, typically in the form HTTP/<hostname>@<REALM>.
	Principal *string `json:"principal,omitempty"`
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `json:"sendToRoutes,omitempty"`
	// How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0.
	SocketTimeout *int64 `json:"socketTimeout,omitempty"`
	// Add tags for filtering and grouping in @{product}.
	Streamtags []string `json:"streamtags,omitempty"`
	// Subscriptions to events on forwarding endpoints.
	Subscriptions []InputWefSubscriptions `json:"subscriptions"`
	TLS           *InputWefMTLSSettings   `json:"tls,omitempty"`
	Type          *InputWefType           `json:"type,omitempty"`
}
