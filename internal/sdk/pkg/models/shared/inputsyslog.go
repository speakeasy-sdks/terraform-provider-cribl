// Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.

package shared

import (
	"bytes"
	"encoding/json"
	"errors"
	"fmt"
)

type InputSyslog2Connections struct {
	// Select a Destination.
	Output string `json:"output"`
	// Select Pipeline or Pack. Optional.
	Pipeline *string `json:"pipeline,omitempty"`
}

type InputSyslog2Metadata struct {
	// Field name
	Name string `json:"name"`
	// JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
	Value string `json:"value"`
}

type InputSyslog2OptionalFieldsInGeneralSection string

const (
	InputSyslog2OptionalFieldsInGeneralSectionUDPPort InputSyslog2OptionalFieldsInGeneralSection = "udpPort"
	InputSyslog2OptionalFieldsInGeneralSectionTCPPort InputSyslog2OptionalFieldsInGeneralSection = "tcpPort"
)

func (e InputSyslog2OptionalFieldsInGeneralSection) ToPointer() *InputSyslog2OptionalFieldsInGeneralSection {
	return &e
}

func (e *InputSyslog2OptionalFieldsInGeneralSection) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "udpPort":
		fallthrough
	case "tcpPort":
		*e = InputSyslog2OptionalFieldsInGeneralSection(v)
		return nil
	default:
		return fmt.Errorf("invalid value for InputSyslog2OptionalFieldsInGeneralSection: %v", v)
	}
}

// InputSyslog2PqCompression - Codec to use to compress the persisted data.
type InputSyslog2PqCompression string

const (
	InputSyslog2PqCompressionNone InputSyslog2PqCompression = "none"
	InputSyslog2PqCompressionGzip InputSyslog2PqCompression = "gzip"
)

func (e InputSyslog2PqCompression) ToPointer() *InputSyslog2PqCompression {
	return &e
}

func (e *InputSyslog2PqCompression) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "none":
		fallthrough
	case "gzip":
		*e = InputSyslog2PqCompression(v)
		return nil
	default:
		return fmt.Errorf("invalid value for InputSyslog2PqCompression: %v", v)
	}
}

// InputSyslog2PqMode - With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
type InputSyslog2PqMode string

const (
	InputSyslog2PqModeSmart  InputSyslog2PqMode = "smart"
	InputSyslog2PqModeAlways InputSyslog2PqMode = "always"
)

func (e InputSyslog2PqMode) ToPointer() *InputSyslog2PqMode {
	return &e
}

func (e *InputSyslog2PqMode) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "smart":
		fallthrough
	case "always":
		*e = InputSyslog2PqMode(v)
		return nil
	default:
		return fmt.Errorf("invalid value for InputSyslog2PqMode: %v", v)
	}
}

type InputSyslog2Pq struct {
	// The number of events to send downstream before committing that Stream has read them.
	CommitFrequency *int64 `json:"commitFrequency,omitempty"`
	// Codec to use to compress the persisted data.
	Compress *InputSyslog2PqCompression `json:"compress,omitempty"`
	// The maximum number of events to hold in memory before writing the events to disk.
	MaxBufferSize *int64 `json:"maxBufferSize,omitempty"`
	// The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.).
	MaxFileSize *string `json:"maxFileSize,omitempty"`
	// The maximum amount of disk space the queue is allowed to consume. Once reached, the system stops queueing and applies the fallback Queue-full behavior. Enter a numeral with units of KB, MB, etc.
	MaxSize *string `json:"maxSize,omitempty"`
	// With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
	Mode *InputSyslog2PqMode `json:"mode,omitempty"`
	// The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>.
	Path *string `json:"path,omitempty"`
}

// InputSyslog2TLSSettingsServerSideMaximumTLSVersion - Maximum TLS version to accept from connections.
type InputSyslog2TLSSettingsServerSideMaximumTLSVersion string

const (
	InputSyslog2TLSSettingsServerSideMaximumTLSVersionTlSv1  InputSyslog2TLSSettingsServerSideMaximumTLSVersion = "TLSv1"
	InputSyslog2TLSSettingsServerSideMaximumTLSVersionTlSv11 InputSyslog2TLSSettingsServerSideMaximumTLSVersion = "TLSv1.1"
	InputSyslog2TLSSettingsServerSideMaximumTLSVersionTlSv12 InputSyslog2TLSSettingsServerSideMaximumTLSVersion = "TLSv1.2"
	InputSyslog2TLSSettingsServerSideMaximumTLSVersionTlSv13 InputSyslog2TLSSettingsServerSideMaximumTLSVersion = "TLSv1.3"
)

func (e InputSyslog2TLSSettingsServerSideMaximumTLSVersion) ToPointer() *InputSyslog2TLSSettingsServerSideMaximumTLSVersion {
	return &e
}

func (e *InputSyslog2TLSSettingsServerSideMaximumTLSVersion) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "TLSv1":
		fallthrough
	case "TLSv1.1":
		fallthrough
	case "TLSv1.2":
		fallthrough
	case "TLSv1.3":
		*e = InputSyslog2TLSSettingsServerSideMaximumTLSVersion(v)
		return nil
	default:
		return fmt.Errorf("invalid value for InputSyslog2TLSSettingsServerSideMaximumTLSVersion: %v", v)
	}
}

// InputSyslog2TLSSettingsServerSideMinimumTLSVersion - Minimum TLS version to accept from connections.
type InputSyslog2TLSSettingsServerSideMinimumTLSVersion string

const (
	InputSyslog2TLSSettingsServerSideMinimumTLSVersionTlSv1  InputSyslog2TLSSettingsServerSideMinimumTLSVersion = "TLSv1"
	InputSyslog2TLSSettingsServerSideMinimumTLSVersionTlSv11 InputSyslog2TLSSettingsServerSideMinimumTLSVersion = "TLSv1.1"
	InputSyslog2TLSSettingsServerSideMinimumTLSVersionTlSv12 InputSyslog2TLSSettingsServerSideMinimumTLSVersion = "TLSv1.2"
	InputSyslog2TLSSettingsServerSideMinimumTLSVersionTlSv13 InputSyslog2TLSSettingsServerSideMinimumTLSVersion = "TLSv1.3"
)

func (e InputSyslog2TLSSettingsServerSideMinimumTLSVersion) ToPointer() *InputSyslog2TLSSettingsServerSideMinimumTLSVersion {
	return &e
}

func (e *InputSyslog2TLSSettingsServerSideMinimumTLSVersion) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "TLSv1":
		fallthrough
	case "TLSv1.1":
		fallthrough
	case "TLSv1.2":
		fallthrough
	case "TLSv1.3":
		*e = InputSyslog2TLSSettingsServerSideMinimumTLSVersion(v)
		return nil
	default:
		return fmt.Errorf("invalid value for InputSyslog2TLSSettingsServerSideMinimumTLSVersion: %v", v)
	}
}

type InputSyslog2TLSSettingsServerSide struct {
	// Path on server containing CA certificates to use. PEM format. Can reference $ENV_VARS.
	CaPath *string `json:"caPath,omitempty"`
	// Path on server containing certificates to use. PEM format. Can reference $ENV_VARS.
	CertPath *string `json:"certPath,omitempty"`
	// The name of the predefined certificate.
	CertificateName *string     `json:"certificateName,omitempty"`
	CommonNameRegex interface{} `json:"commonNameRegex,omitempty"`
	Disabled        *bool       `json:"disabled,omitempty"`
	// Maximum TLS version to accept from connections.
	MaxVersion *InputSyslog2TLSSettingsServerSideMaximumTLSVersion `json:"maxVersion,omitempty"`
	// Minimum TLS version to accept from connections.
	MinVersion *InputSyslog2TLSSettingsServerSideMinimumTLSVersion `json:"minVersion,omitempty"`
	// Passphrase to use to decrypt private key.
	Passphrase *string `json:"passphrase,omitempty"`
	// Path on server containing the private key to use. PEM format. Can reference $ENV_VARS.
	PrivKeyPath        *string     `json:"privKeyPath,omitempty"`
	RejectUnauthorized interface{} `json:"rejectUnauthorized,omitempty"`
	// Whether to require clients to present their certificates. Used to perform client authentication using SSL certs.
	RequestCert *bool `json:"requestCert,omitempty"`
}

type InputSyslog2Type string

const (
	InputSyslog2TypeSyslog InputSyslog2Type = "syslog"
)

func (e InputSyslog2Type) ToPointer() *InputSyslog2Type {
	return &e
}

func (e *InputSyslog2Type) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "syslog":
		*e = InputSyslog2Type(v)
		return nil
	default:
		return fmt.Errorf("invalid value for InputSyslog2Type: %v", v)
	}
}

type InputSyslog2 struct {
	// Enable if RFC 3164-formatted messages have hyphens in the app name portion of the TAG section. If disabled, only alphanumeric characters and underscores are allowed. Ignored for RFC 5424-formatted messages.
	AllowNonStandardAppName *bool `json:"allowNonStandardAppName,omitempty"`
	// Direct connections to Destinations, optionally via a Pipeline or a Pack.
	Connections []InputSyslog2Connections `json:"connections,omitempty"`
	// Enable/disable this input
	Disabled *bool `json:"disabled,omitempty"`
	// Enable if the connection is proxied by a device that supports Proxy Protocol V1 or V2
	EnableProxyHeader *bool `json:"enableProxyHeader,omitempty"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Address to bind on. For IPv4 (all addresses), use the default '0.0.0.0'. For IPv6, enter '::' (all addresses) or specify an IP address.
	Host string `json:"host"`
	// Unique ID for this input
	ID *string `json:"id,omitempty"`
	// Regex matching IP addresses that are allowed to send data
	IPWhitelistRegex *string `json:"ipWhitelistRegex,omitempty"`
	// Wildcard list of fields to keep from source data, * = ALL (default)
	KeepFieldsList []string `json:"keepFieldsList,omitempty"`
	// Maximum number of events to buffer when downstream is blocking. Only applies to UDP.
	MaxBufferSize *int64 `json:"maxBufferSize,omitempty"`
	// Fields to add to events from this input.
	Metadata []InputSyslog2Metadata `json:"metadata,omitempty"`
	// Enable if incoming messages use octet counting per RFC 6587.
	OctetCounting                  *bool                                       `json:"octetCounting,omitempty"`
	OptionalFieldsInGeneralSection *InputSyslog2OptionalFieldsInGeneralSection `json:"optionalFieldsInGeneralSection,omitempty"`
	// Pipeline to process data from this Source before sending it through the Routes.
	Pipeline *string         `json:"pipeline,omitempty"`
	Pq       *InputSyslog2Pq `json:"pq,omitempty"`
	// For details on Persistent Queues, see: [https://docs.cribl.io/stream/persistent-queues](https://docs.cribl.io/stream/persistent-queues)
	PqEnabled *bool `json:"pqEnabled,omitempty"`
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `json:"sendToRoutes,omitempty"`
	// Whether to treat UDP packet data received as full syslog message
	SingleMsgUDPPackets *bool `json:"singleMsgUdpPackets,omitempty"`
	// Add tags for filtering and grouping in @{product}.
	Streamtags []string `json:"streamtags,omitempty"`
	// Enter TCP port number to listen on. Not required if listening on UDP.
	TCPPort int64 `json:"tcpPort"`
	// Timezone to assign to timestamps without timezone info.
	TimestampTimezone *string                            `json:"timestampTimezone,omitempty"`
	TLS               *InputSyslog2TLSSettingsServerSide `json:"tls,omitempty"`
	Type              InputSyslog2Type                   `json:"type"`
	// Enter UDP port number to listen on. Not required if listening on TCP.
	UDPPort *int64 `json:"udpPort,omitempty"`
}

type InputSyslog1Connections struct {
	// Select a Destination.
	Output string `json:"output"`
	// Select Pipeline or Pack. Optional.
	Pipeline *string `json:"pipeline,omitempty"`
}

type InputSyslog1Metadata struct {
	// Field name
	Name string `json:"name"`
	// JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
	Value string `json:"value"`
}

type InputSyslog1OptionalFieldsInGeneralSection string

const (
	InputSyslog1OptionalFieldsInGeneralSectionUDPPort InputSyslog1OptionalFieldsInGeneralSection = "udpPort"
	InputSyslog1OptionalFieldsInGeneralSectionTCPPort InputSyslog1OptionalFieldsInGeneralSection = "tcpPort"
)

func (e InputSyslog1OptionalFieldsInGeneralSection) ToPointer() *InputSyslog1OptionalFieldsInGeneralSection {
	return &e
}

func (e *InputSyslog1OptionalFieldsInGeneralSection) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "udpPort":
		fallthrough
	case "tcpPort":
		*e = InputSyslog1OptionalFieldsInGeneralSection(v)
		return nil
	default:
		return fmt.Errorf("invalid value for InputSyslog1OptionalFieldsInGeneralSection: %v", v)
	}
}

// InputSyslog1PqCompression - Codec to use to compress the persisted data.
type InputSyslog1PqCompression string

const (
	InputSyslog1PqCompressionNone InputSyslog1PqCompression = "none"
	InputSyslog1PqCompressionGzip InputSyslog1PqCompression = "gzip"
)

func (e InputSyslog1PqCompression) ToPointer() *InputSyslog1PqCompression {
	return &e
}

func (e *InputSyslog1PqCompression) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "none":
		fallthrough
	case "gzip":
		*e = InputSyslog1PqCompression(v)
		return nil
	default:
		return fmt.Errorf("invalid value for InputSyslog1PqCompression: %v", v)
	}
}

// InputSyslog1PqMode - With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
type InputSyslog1PqMode string

const (
	InputSyslog1PqModeSmart  InputSyslog1PqMode = "smart"
	InputSyslog1PqModeAlways InputSyslog1PqMode = "always"
)

func (e InputSyslog1PqMode) ToPointer() *InputSyslog1PqMode {
	return &e
}

func (e *InputSyslog1PqMode) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "smart":
		fallthrough
	case "always":
		*e = InputSyslog1PqMode(v)
		return nil
	default:
		return fmt.Errorf("invalid value for InputSyslog1PqMode: %v", v)
	}
}

type InputSyslog1Pq struct {
	// The number of events to send downstream before committing that Stream has read them.
	CommitFrequency *int64 `json:"commitFrequency,omitempty"`
	// Codec to use to compress the persisted data.
	Compress *InputSyslog1PqCompression `json:"compress,omitempty"`
	// The maximum number of events to hold in memory before writing the events to disk.
	MaxBufferSize *int64 `json:"maxBufferSize,omitempty"`
	// The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.).
	MaxFileSize *string `json:"maxFileSize,omitempty"`
	// The maximum amount of disk space the queue is allowed to consume. Once reached, the system stops queueing and applies the fallback Queue-full behavior. Enter a numeral with units of KB, MB, etc.
	MaxSize *string `json:"maxSize,omitempty"`
	// With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
	Mode *InputSyslog1PqMode `json:"mode,omitempty"`
	// The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>.
	Path *string `json:"path,omitempty"`
}

// InputSyslog1TLSSettingsServerSideMaximumTLSVersion - Maximum TLS version to accept from connections.
type InputSyslog1TLSSettingsServerSideMaximumTLSVersion string

const (
	InputSyslog1TLSSettingsServerSideMaximumTLSVersionTlSv1  InputSyslog1TLSSettingsServerSideMaximumTLSVersion = "TLSv1"
	InputSyslog1TLSSettingsServerSideMaximumTLSVersionTlSv11 InputSyslog1TLSSettingsServerSideMaximumTLSVersion = "TLSv1.1"
	InputSyslog1TLSSettingsServerSideMaximumTLSVersionTlSv12 InputSyslog1TLSSettingsServerSideMaximumTLSVersion = "TLSv1.2"
	InputSyslog1TLSSettingsServerSideMaximumTLSVersionTlSv13 InputSyslog1TLSSettingsServerSideMaximumTLSVersion = "TLSv1.3"
)

func (e InputSyslog1TLSSettingsServerSideMaximumTLSVersion) ToPointer() *InputSyslog1TLSSettingsServerSideMaximumTLSVersion {
	return &e
}

func (e *InputSyslog1TLSSettingsServerSideMaximumTLSVersion) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "TLSv1":
		fallthrough
	case "TLSv1.1":
		fallthrough
	case "TLSv1.2":
		fallthrough
	case "TLSv1.3":
		*e = InputSyslog1TLSSettingsServerSideMaximumTLSVersion(v)
		return nil
	default:
		return fmt.Errorf("invalid value for InputSyslog1TLSSettingsServerSideMaximumTLSVersion: %v", v)
	}
}

// InputSyslog1TLSSettingsServerSideMinimumTLSVersion - Minimum TLS version to accept from connections.
type InputSyslog1TLSSettingsServerSideMinimumTLSVersion string

const (
	InputSyslog1TLSSettingsServerSideMinimumTLSVersionTlSv1  InputSyslog1TLSSettingsServerSideMinimumTLSVersion = "TLSv1"
	InputSyslog1TLSSettingsServerSideMinimumTLSVersionTlSv11 InputSyslog1TLSSettingsServerSideMinimumTLSVersion = "TLSv1.1"
	InputSyslog1TLSSettingsServerSideMinimumTLSVersionTlSv12 InputSyslog1TLSSettingsServerSideMinimumTLSVersion = "TLSv1.2"
	InputSyslog1TLSSettingsServerSideMinimumTLSVersionTlSv13 InputSyslog1TLSSettingsServerSideMinimumTLSVersion = "TLSv1.3"
)

func (e InputSyslog1TLSSettingsServerSideMinimumTLSVersion) ToPointer() *InputSyslog1TLSSettingsServerSideMinimumTLSVersion {
	return &e
}

func (e *InputSyslog1TLSSettingsServerSideMinimumTLSVersion) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "TLSv1":
		fallthrough
	case "TLSv1.1":
		fallthrough
	case "TLSv1.2":
		fallthrough
	case "TLSv1.3":
		*e = InputSyslog1TLSSettingsServerSideMinimumTLSVersion(v)
		return nil
	default:
		return fmt.Errorf("invalid value for InputSyslog1TLSSettingsServerSideMinimumTLSVersion: %v", v)
	}
}

type InputSyslog1TLSSettingsServerSide struct {
	// Path on server containing CA certificates to use. PEM format. Can reference $ENV_VARS.
	CaPath *string `json:"caPath,omitempty"`
	// Path on server containing certificates to use. PEM format. Can reference $ENV_VARS.
	CertPath *string `json:"certPath,omitempty"`
	// The name of the predefined certificate.
	CertificateName *string     `json:"certificateName,omitempty"`
	CommonNameRegex interface{} `json:"commonNameRegex,omitempty"`
	Disabled        *bool       `json:"disabled,omitempty"`
	// Maximum TLS version to accept from connections.
	MaxVersion *InputSyslog1TLSSettingsServerSideMaximumTLSVersion `json:"maxVersion,omitempty"`
	// Minimum TLS version to accept from connections.
	MinVersion *InputSyslog1TLSSettingsServerSideMinimumTLSVersion `json:"minVersion,omitempty"`
	// Passphrase to use to decrypt private key.
	Passphrase *string `json:"passphrase,omitempty"`
	// Path on server containing the private key to use. PEM format. Can reference $ENV_VARS.
	PrivKeyPath        *string     `json:"privKeyPath,omitempty"`
	RejectUnauthorized interface{} `json:"rejectUnauthorized,omitempty"`
	// Whether to require clients to present their certificates. Used to perform client authentication using SSL certs.
	RequestCert *bool `json:"requestCert,omitempty"`
}

type InputSyslog1Type string

const (
	InputSyslog1TypeSyslog InputSyslog1Type = "syslog"
)

func (e InputSyslog1Type) ToPointer() *InputSyslog1Type {
	return &e
}

func (e *InputSyslog1Type) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "syslog":
		*e = InputSyslog1Type(v)
		return nil
	default:
		return fmt.Errorf("invalid value for InputSyslog1Type: %v", v)
	}
}

type InputSyslog1 struct {
	// Enable if RFC 3164-formatted messages have hyphens in the app name portion of the TAG section. If disabled, only alphanumeric characters and underscores are allowed. Ignored for RFC 5424-formatted messages.
	AllowNonStandardAppName *bool `json:"allowNonStandardAppName,omitempty"`
	// Direct connections to Destinations, optionally via a Pipeline or a Pack.
	Connections []InputSyslog1Connections `json:"connections,omitempty"`
	// Enable/disable this input
	Disabled *bool `json:"disabled,omitempty"`
	// Enable if the connection is proxied by a device that supports Proxy Protocol V1 or V2
	EnableProxyHeader *bool `json:"enableProxyHeader,omitempty"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Address to bind on. For IPv4 (all addresses), use the default '0.0.0.0'. For IPv6, enter '::' (all addresses) or specify an IP address.
	Host string `json:"host"`
	// Unique ID for this input
	ID *string `json:"id,omitempty"`
	// Regex matching IP addresses that are allowed to send data
	IPWhitelistRegex *string `json:"ipWhitelistRegex,omitempty"`
	// Wildcard list of fields to keep from source data, * = ALL (default)
	KeepFieldsList []string `json:"keepFieldsList,omitempty"`
	// Maximum number of events to buffer when downstream is blocking. Only applies to UDP.
	MaxBufferSize *int64 `json:"maxBufferSize,omitempty"`
	// Fields to add to events from this input.
	Metadata []InputSyslog1Metadata `json:"metadata,omitempty"`
	// Enable if incoming messages use octet counting per RFC 6587.
	OctetCounting                  *bool                                       `json:"octetCounting,omitempty"`
	OptionalFieldsInGeneralSection *InputSyslog1OptionalFieldsInGeneralSection `json:"optionalFieldsInGeneralSection,omitempty"`
	// Pipeline to process data from this Source before sending it through the Routes.
	Pipeline *string         `json:"pipeline,omitempty"`
	Pq       *InputSyslog1Pq `json:"pq,omitempty"`
	// For details on Persistent Queues, see: [https://docs.cribl.io/stream/persistent-queues](https://docs.cribl.io/stream/persistent-queues)
	PqEnabled *bool `json:"pqEnabled,omitempty"`
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `json:"sendToRoutes,omitempty"`
	// Whether to treat UDP packet data received as full syslog message
	SingleMsgUDPPackets *bool `json:"singleMsgUdpPackets,omitempty"`
	// Add tags for filtering and grouping in @{product}.
	Streamtags []string `json:"streamtags,omitempty"`
	// Enter TCP port number to listen on. Not required if listening on UDP.
	TCPPort *int64 `json:"tcpPort,omitempty"`
	// Timezone to assign to timestamps without timezone info.
	TimestampTimezone *string                            `json:"timestampTimezone,omitempty"`
	TLS               *InputSyslog1TLSSettingsServerSide `json:"tls,omitempty"`
	Type              InputSyslog1Type                   `json:"type"`
	// Enter UDP port number to listen on. Not required if listening on TCP.
	UDPPort int64 `json:"udpPort"`
}

type InputSyslogType string

const (
	InputSyslogTypeInputSyslog1 InputSyslogType = "InputSyslog_1"
	InputSyslogTypeInputSyslog2 InputSyslogType = "InputSyslog_2"
)

type InputSyslog struct {
	InputSyslog1 *InputSyslog1
	InputSyslog2 *InputSyslog2

	Type InputSyslogType
}

func CreateInputSyslogInputSyslog1(inputSyslog1 InputSyslog1) InputSyslog {
	typ := InputSyslogTypeInputSyslog1

	return InputSyslog{
		InputSyslog1: &inputSyslog1,
		Type:         typ,
	}
}

func CreateInputSyslogInputSyslog2(inputSyslog2 InputSyslog2) InputSyslog {
	typ := InputSyslogTypeInputSyslog2

	return InputSyslog{
		InputSyslog2: &inputSyslog2,
		Type:         typ,
	}
}

func (u *InputSyslog) UnmarshalJSON(data []byte) error {
	var d *json.Decoder

	inputSyslog1 := new(InputSyslog1)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&inputSyslog1); err == nil {
		u.InputSyslog1 = inputSyslog1
		u.Type = InputSyslogTypeInputSyslog1
		return nil
	}

	inputSyslog2 := new(InputSyslog2)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&inputSyslog2); err == nil {
		u.InputSyslog2 = inputSyslog2
		u.Type = InputSyslogTypeInputSyslog2
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u InputSyslog) MarshalJSON() ([]byte, error) {
	if u.InputSyslog1 != nil {
		return json.Marshal(u.InputSyslog1)
	}

	if u.InputSyslog2 != nil {
		return json.Marshal(u.InputSyslog2)
	}

	return nil, nil
}
