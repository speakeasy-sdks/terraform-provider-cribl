// Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.

package shared

import (
	"encoding/json"
	"fmt"
)

type EventBreakerRulesetLibrary string

const (
	EventBreakerRulesetLibraryCustom EventBreakerRulesetLibrary = "custom"
)

func (e EventBreakerRulesetLibrary) ToPointer() *EventBreakerRulesetLibrary {
	return &e
}

func (e *EventBreakerRulesetLibrary) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "custom":
		*e = EventBreakerRulesetLibrary(v)
		return nil
	default:
		return fmt.Errorf("invalid value for EventBreakerRulesetLibrary: %v", v)
	}
}

type EventBreakerRulesetRulesDefinitions struct {
	// Name of the field to add fields to. Extract mode only.
	DstField *string `json:"dstField,omitempty"`
	// Expression evaluated against {index, name, value} context. Return truthy to keep a field, or falsy to remove it.
	FieldFilterExpr *string `json:"fieldFilterExpr,omitempty"`
	// Fields expected to be extracted, in order. If not specified, Parser will auto-generate.
	Fields []string `json:"fields,omitempty"`
	// List of fields to keep. Supports wildcards (*). Takes precedence over 'Fields to Remove'.
	Keep []string `json:"keep,omitempty"`
	// List of fields to remove. Supports wildcards (*). Cannot remove fields that match 'Fields to Keep'.
	Remove []string `json:"remove,omitempty"`
}

type EventBreakerRulesetRulesFields struct {
	// Field Name.
	Name *string `json:"name,omitempty"`
	// JavaScript expression to compute fields value (can be constant).
	Value string `json:"value"`
}

type EventBreakerRulesetRulesTimestampFormatTimestampType string

const (
	EventBreakerRulesetRulesTimestampFormatTimestampTypeAuto    EventBreakerRulesetRulesTimestampFormatTimestampType = "auto"
	EventBreakerRulesetRulesTimestampFormatTimestampTypeFormat  EventBreakerRulesetRulesTimestampFormatTimestampType = "format"
	EventBreakerRulesetRulesTimestampFormatTimestampTypeCurrent EventBreakerRulesetRulesTimestampFormatTimestampType = "current"
)

func (e EventBreakerRulesetRulesTimestampFormatTimestampType) ToPointer() *EventBreakerRulesetRulesTimestampFormatTimestampType {
	return &e
}

func (e *EventBreakerRulesetRulesTimestampFormatTimestampType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "auto":
		fallthrough
	case "format":
		fallthrough
	case "current":
		*e = EventBreakerRulesetRulesTimestampFormatTimestampType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for EventBreakerRulesetRulesTimestampFormatTimestampType: %v", v)
	}
}

// EventBreakerRulesetRulesTimestampFormat - Auto, manual format (strptime) or current time.
type EventBreakerRulesetRulesTimestampFormat struct {
	Format *string                                              `json:"format,omitempty"`
	Length *int64                                               `json:"length,omitempty"`
	Type   EventBreakerRulesetRulesTimestampFormatTimestampType `json:"type"`
}

// EventBreakerRulesetRulesEventBreakerType - Event Breaker Type
type EventBreakerRulesetRulesEventBreakerType string

const (
	EventBreakerRulesetRulesEventBreakerTypeRegex     EventBreakerRulesetRulesEventBreakerType = "regex"
	EventBreakerRulesetRulesEventBreakerTypeJSON      EventBreakerRulesetRulesEventBreakerType = "json"
	EventBreakerRulesetRulesEventBreakerTypeJSONArray EventBreakerRulesetRulesEventBreakerType = "json_array"
	EventBreakerRulesetRulesEventBreakerTypeHeader    EventBreakerRulesetRulesEventBreakerType = "header"
	EventBreakerRulesetRulesEventBreakerTypeTimestamp EventBreakerRulesetRulesEventBreakerType = "timestamp"
	EventBreakerRulesetRulesEventBreakerTypeCsv       EventBreakerRulesetRulesEventBreakerType = "csv"
)

func (e EventBreakerRulesetRulesEventBreakerType) ToPointer() *EventBreakerRulesetRulesEventBreakerType {
	return &e
}

func (e *EventBreakerRulesetRulesEventBreakerType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "regex":
		fallthrough
	case "json":
		fallthrough
	case "json_array":
		fallthrough
	case "header":
		fallthrough
	case "timestamp":
		fallthrough
	case "csv":
		*e = EventBreakerRulesetRulesEventBreakerType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for EventBreakerRulesetRulesEventBreakerType: %v", v)
	}
}

type EventBreakerRulesetRules struct {
	// Filter expression (JS) that matches data to apply rule to. To test your sample, use the maximize icon on the right.
	Condition   string                               `json:"condition"`
	Definitions *EventBreakerRulesetRulesDefinitions `json:"definitions,omitempty"`
	// Allows breaker rule to be enabled or disabled, default is enabled.
	Disabled *bool `json:"disabled,omitempty"`
	// Key value pairs to be added to each event.
	Fields []EventBreakerRulesetRulesFields `json:"fields,omitempty"`
	// The maximum number of bytes that an event can be before being flushed to the pipelines
	MaxEventBytes *int64 `json:"maxEventBytes,omitempty"`
	Name          string `json:"name"`
	// Parser.
	ParserEnabled *bool `json:"parserEnabled,omitempty"`
	// Auto, manual format (strptime) or current time.
	Timestamp EventBreakerRulesetRulesTimestampFormat `json:"timestamp"`
	// Regex to match before attempting timestamp extraction. Use $ (end of string anchor) to not perform extraction.
	TimestampAnchorRegex string `json:"timestampAnchorRegex"`
	// The earliest timestamp value allowed relative to now. E.g., -42years. Parsed values prior to this date will be set to current time.
	TimestampEarliest *string `json:"timestampEarliest,omitempty"`
	// The latest timestamp value allowed relative to now. E.g., +42days. Parsed values after this date will be set to current time.
	TimestampLatest *string `json:"timestampLatest,omitempty"`
	// Timezone to assign to timestamps without timezone info.
	TimestampTimezone *string `json:"timestampTimezone,omitempty"`
	// Event Breaker Type
	Type EventBreakerRulesetRulesEventBreakerType `json:"type"`
}

// EventBreakerRuleset - New Event Breaker Ruleset object
type EventBreakerRuleset struct {
	// Brief description of this ruleset. Optional.
	Description *string                     `json:"description,omitempty"`
	ID          string                      `json:"id"`
	Lib         *EventBreakerRulesetLibrary `json:"lib,omitempty"`
	// Threshold number of characters in _raw to determine which rule to use.
	MinRawLength *int64 `json:"minRawLength,omitempty"`
	// List of rules. Evaluated in order, top down.
	Rules []EventBreakerRulesetRules `json:"rules,omitempty"`
	// One or more tags related to this ruleset. Optional.
	Tags *string `json:"tags,omitempty"`
}
