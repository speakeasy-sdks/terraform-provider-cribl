// Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.

package shared

import (
	"encoding/json"
	"fmt"
)

// OutputSplunkLbAuthenticationMethod - Enter a token directly, or provide a secret referencing a token
type OutputSplunkLbAuthenticationMethod string

const (
	OutputSplunkLbAuthenticationMethodSecret OutputSplunkLbAuthenticationMethod = "secret"
	OutputSplunkLbAuthenticationMethodManual OutputSplunkLbAuthenticationMethod = "manual"
)

func (e OutputSplunkLbAuthenticationMethod) ToPointer() *OutputSplunkLbAuthenticationMethod {
	return &e
}

func (e *OutputSplunkLbAuthenticationMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "secret":
		fallthrough
	case "manual":
		*e = OutputSplunkLbAuthenticationMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for OutputSplunkLbAuthenticationMethod: %v", v)
	}
}

// OutputSplunkLbHostsTLS - Whether to inherit TLS configs from group setting or disable TLS.
type OutputSplunkLbHostsTLS string

const (
	OutputSplunkLbHostsTLSInherit OutputSplunkLbHostsTLS = "inherit"
	OutputSplunkLbHostsTLSOff     OutputSplunkLbHostsTLS = "off"
)

func (e OutputSplunkLbHostsTLS) ToPointer() *OutputSplunkLbHostsTLS {
	return &e
}

func (e *OutputSplunkLbHostsTLS) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "inherit":
		fallthrough
	case "off":
		*e = OutputSplunkLbHostsTLS(v)
		return nil
	default:
		return fmt.Errorf("invalid value for OutputSplunkLbHostsTLS: %v", v)
	}
}

type OutputSplunkLbHosts struct {
	// The hostname of the receiver.
	Host string `json:"host"`
	// The port to connect to on the provided host.
	Port int64 `json:"port"`
	// Servername to use if establishing a TLS connection. If not specified, defaults to connection host (iff not an IP); otherwise, to the global TLS settings.
	Servername *string `json:"servername,omitempty"`
	// Whether to inherit TLS configs from group setting or disable TLS.
	TLS *OutputSplunkLbHostsTLS `json:"tls,omitempty"`
	// The weight to use for load-balancing purposes.
	Weight *int64 `json:"weight,omitempty"`
}

// OutputSplunkLbIndexerDiscoveryConfigsAuthenticationMethod - Enter a token directly, or provide a secret referencing a token
type OutputSplunkLbIndexerDiscoveryConfigsAuthenticationMethod string

const (
	OutputSplunkLbIndexerDiscoveryConfigsAuthenticationMethodSecret OutputSplunkLbIndexerDiscoveryConfigsAuthenticationMethod = "secret"
	OutputSplunkLbIndexerDiscoveryConfigsAuthenticationMethodManual OutputSplunkLbIndexerDiscoveryConfigsAuthenticationMethod = "manual"
)

func (e OutputSplunkLbIndexerDiscoveryConfigsAuthenticationMethod) ToPointer() *OutputSplunkLbIndexerDiscoveryConfigsAuthenticationMethod {
	return &e
}

func (e *OutputSplunkLbIndexerDiscoveryConfigsAuthenticationMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "secret":
		fallthrough
	case "manual":
		*e = OutputSplunkLbIndexerDiscoveryConfigsAuthenticationMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for OutputSplunkLbIndexerDiscoveryConfigsAuthenticationMethod: %v", v)
	}
}

// OutputSplunkLbIndexerDiscoveryConfigs - List of configurations to set up indexer discovery in Splunk Indexer clustering environment.
type OutputSplunkLbIndexerDiscoveryConfigs struct {
	// Authentication token required to authenticate to cluster Manager for indexer discovery.
	AuthToken *string `json:"authToken,omitempty"`
	// Enter a token directly, or provide a secret referencing a token
	AuthType *OutputSplunkLbIndexerDiscoveryConfigsAuthenticationMethod `json:"authType,omitempty"`
	// Full URI of Splunk cluster Manager (scheme://host:port). E.g.: https://managerAddress:8089
	MasterURI string `json:"masterUri"`
	// Time interval in seconds between two consecutive indexer list fetches from cluster Manager.
	RefreshIntervalSec int64 `json:"refreshIntervalSec"`
	// Clustering site of the indexers from where indexers need to be discovered. In case of single site cluster, it defaults to 'default' site.
	Site string `json:"site"`
	// Select (or create) a stored text secret
	TextSecret *string `json:"textSecret,omitempty"`
}

// OutputSplunkLbMaxS2SVersion - The highest S2S protocol version to advertise during handshake.
type OutputSplunkLbMaxS2SVersion string

const (
	OutputSplunkLbMaxS2SVersionV3 OutputSplunkLbMaxS2SVersion = "v3"
	OutputSplunkLbMaxS2SVersionV4 OutputSplunkLbMaxS2SVersion = "v4"
)

func (e OutputSplunkLbMaxS2SVersion) ToPointer() *OutputSplunkLbMaxS2SVersion {
	return &e
}

func (e *OutputSplunkLbMaxS2SVersion) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "v3":
		fallthrough
	case "v4":
		*e = OutputSplunkLbMaxS2SVersion(v)
		return nil
	default:
		return fmt.Errorf("invalid value for OutputSplunkLbMaxS2SVersion: %v", v)
	}
}

// OutputSplunkLbNestedFieldSerialization - Specifies how to serialize nested fields into index-time fields.
type OutputSplunkLbNestedFieldSerialization string

const (
	OutputSplunkLbNestedFieldSerializationJSON OutputSplunkLbNestedFieldSerialization = "json"
	OutputSplunkLbNestedFieldSerializationNone OutputSplunkLbNestedFieldSerialization = "none"
)

func (e OutputSplunkLbNestedFieldSerialization) ToPointer() *OutputSplunkLbNestedFieldSerialization {
	return &e
}

func (e *OutputSplunkLbNestedFieldSerialization) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "json":
		fallthrough
	case "none":
		*e = OutputSplunkLbNestedFieldSerialization(v)
		return nil
	default:
		return fmt.Errorf("invalid value for OutputSplunkLbNestedFieldSerialization: %v", v)
	}
}

// OutputSplunkLbBackpressureBehavior - Whether to block, drop, or queue events when all receivers are exerting backpressure.
type OutputSplunkLbBackpressureBehavior string

const (
	OutputSplunkLbBackpressureBehaviorQueue OutputSplunkLbBackpressureBehavior = "queue"
	OutputSplunkLbBackpressureBehaviorDrop  OutputSplunkLbBackpressureBehavior = "drop"
	OutputSplunkLbBackpressureBehaviorBlock OutputSplunkLbBackpressureBehavior = "block"
)

func (e OutputSplunkLbBackpressureBehavior) ToPointer() *OutputSplunkLbBackpressureBehavior {
	return &e
}

func (e *OutputSplunkLbBackpressureBehavior) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "queue":
		fallthrough
	case "drop":
		fallthrough
	case "block":
		*e = OutputSplunkLbBackpressureBehavior(v)
		return nil
	default:
		return fmt.Errorf("invalid value for OutputSplunkLbBackpressureBehavior: %v", v)
	}
}

type OutputSplunkLbOptionalFieldsInGeneralSection string

const (
	OutputSplunkLbOptionalFieldsInGeneralSectionIndexerDiscovery        OutputSplunkLbOptionalFieldsInGeneralSection = "indexerDiscovery"
	OutputSplunkLbOptionalFieldsInGeneralSectionIndexerDiscoveryConfigs OutputSplunkLbOptionalFieldsInGeneralSection = "indexerDiscoveryConfigs"
)

func (e OutputSplunkLbOptionalFieldsInGeneralSection) ToPointer() *OutputSplunkLbOptionalFieldsInGeneralSection {
	return &e
}

func (e *OutputSplunkLbOptionalFieldsInGeneralSection) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "indexerDiscovery":
		fallthrough
	case "indexerDiscoveryConfigs":
		*e = OutputSplunkLbOptionalFieldsInGeneralSection(v)
		return nil
	default:
		return fmt.Errorf("invalid value for OutputSplunkLbOptionalFieldsInGeneralSection: %v", v)
	}
}

// OutputSplunkLbCompression - Codec to use to compress the persisted data.
type OutputSplunkLbCompression string

const (
	OutputSplunkLbCompressionNone OutputSplunkLbCompression = "none"
	OutputSplunkLbCompressionGzip OutputSplunkLbCompression = "gzip"
)

func (e OutputSplunkLbCompression) ToPointer() *OutputSplunkLbCompression {
	return &e
}

func (e *OutputSplunkLbCompression) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "none":
		fallthrough
	case "gzip":
		*e = OutputSplunkLbCompression(v)
		return nil
	default:
		return fmt.Errorf("invalid value for OutputSplunkLbCompression: %v", v)
	}
}

type OutputSplunkLbPqControls struct {
}

// OutputSplunkLbQueueFullBehavior - Whether to block or drop events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
type OutputSplunkLbQueueFullBehavior string

const (
	OutputSplunkLbQueueFullBehaviorBlock OutputSplunkLbQueueFullBehavior = "block"
	OutputSplunkLbQueueFullBehaviorDrop  OutputSplunkLbQueueFullBehavior = "drop"
)

func (e OutputSplunkLbQueueFullBehavior) ToPointer() *OutputSplunkLbQueueFullBehavior {
	return &e
}

func (e *OutputSplunkLbQueueFullBehavior) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "block":
		fallthrough
	case "drop":
		*e = OutputSplunkLbQueueFullBehavior(v)
		return nil
	default:
		return fmt.Errorf("invalid value for OutputSplunkLbQueueFullBehavior: %v", v)
	}
}

// OutputSplunkLbTLSSettingsClientSideMaximumTLSVersion - Maximum TLS version to use when connecting
type OutputSplunkLbTLSSettingsClientSideMaximumTLSVersion string

const (
	OutputSplunkLbTLSSettingsClientSideMaximumTLSVersionTlSv1  OutputSplunkLbTLSSettingsClientSideMaximumTLSVersion = "TLSv1"
	OutputSplunkLbTLSSettingsClientSideMaximumTLSVersionTlSv11 OutputSplunkLbTLSSettingsClientSideMaximumTLSVersion = "TLSv1.1"
	OutputSplunkLbTLSSettingsClientSideMaximumTLSVersionTlSv12 OutputSplunkLbTLSSettingsClientSideMaximumTLSVersion = "TLSv1.2"
	OutputSplunkLbTLSSettingsClientSideMaximumTLSVersionTlSv13 OutputSplunkLbTLSSettingsClientSideMaximumTLSVersion = "TLSv1.3"
)

func (e OutputSplunkLbTLSSettingsClientSideMaximumTLSVersion) ToPointer() *OutputSplunkLbTLSSettingsClientSideMaximumTLSVersion {
	return &e
}

func (e *OutputSplunkLbTLSSettingsClientSideMaximumTLSVersion) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "TLSv1":
		fallthrough
	case "TLSv1.1":
		fallthrough
	case "TLSv1.2":
		fallthrough
	case "TLSv1.3":
		*e = OutputSplunkLbTLSSettingsClientSideMaximumTLSVersion(v)
		return nil
	default:
		return fmt.Errorf("invalid value for OutputSplunkLbTLSSettingsClientSideMaximumTLSVersion: %v", v)
	}
}

// OutputSplunkLbTLSSettingsClientSideMinimumTLSVersion - Minimum TLS version to use when connecting
type OutputSplunkLbTLSSettingsClientSideMinimumTLSVersion string

const (
	OutputSplunkLbTLSSettingsClientSideMinimumTLSVersionTlSv1  OutputSplunkLbTLSSettingsClientSideMinimumTLSVersion = "TLSv1"
	OutputSplunkLbTLSSettingsClientSideMinimumTLSVersionTlSv11 OutputSplunkLbTLSSettingsClientSideMinimumTLSVersion = "TLSv1.1"
	OutputSplunkLbTLSSettingsClientSideMinimumTLSVersionTlSv12 OutputSplunkLbTLSSettingsClientSideMinimumTLSVersion = "TLSv1.2"
	OutputSplunkLbTLSSettingsClientSideMinimumTLSVersionTlSv13 OutputSplunkLbTLSSettingsClientSideMinimumTLSVersion = "TLSv1.3"
)

func (e OutputSplunkLbTLSSettingsClientSideMinimumTLSVersion) ToPointer() *OutputSplunkLbTLSSettingsClientSideMinimumTLSVersion {
	return &e
}

func (e *OutputSplunkLbTLSSettingsClientSideMinimumTLSVersion) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "TLSv1":
		fallthrough
	case "TLSv1.1":
		fallthrough
	case "TLSv1.2":
		fallthrough
	case "TLSv1.3":
		*e = OutputSplunkLbTLSSettingsClientSideMinimumTLSVersion(v)
		return nil
	default:
		return fmt.Errorf("invalid value for OutputSplunkLbTLSSettingsClientSideMinimumTLSVersion: %v", v)
	}
}

type OutputSplunkLbTLSSettingsClientSide struct {
	// Path on client in which to find CA certificates to verify the server's cert. PEM format. Can reference $ENV_VARS.
	CaPath *string `json:"caPath,omitempty"`
	// Path on client in which to find certificates to use. PEM format. Can reference $ENV_VARS.
	CertPath *string `json:"certPath,omitempty"`
	// The name of the predefined certificate.
	CertificateName *string `json:"certificateName,omitempty"`
	Disabled        *bool   `json:"disabled,omitempty"`
	// Maximum TLS version to use when connecting
	MaxVersion *OutputSplunkLbTLSSettingsClientSideMaximumTLSVersion `json:"maxVersion,omitempty"`
	// Minimum TLS version to use when connecting
	MinVersion *OutputSplunkLbTLSSettingsClientSideMinimumTLSVersion `json:"minVersion,omitempty"`
	// Passphrase to use to decrypt private key.
	Passphrase *string `json:"passphrase,omitempty"`
	// Path on client in which to find the private key to use. PEM format. Can reference $ENV_VARS.
	PrivKeyPath *string `json:"privKeyPath,omitempty"`
	// Reject certs that are not authorized by a CA in the CA certificate path, or by another trusted CA (e.g., the system's CA). Defaults to No.
	RejectUnauthorized *bool `json:"rejectUnauthorized,omitempty"`
	// Server name for the SNI (Server Name Indication) TLS extension. It must be a host name, and not an IP address.
	Servername *string `json:"servername,omitempty"`
}

type OutputSplunkLbType string

const (
	OutputSplunkLbTypeSplunkLb OutputSplunkLbType = "splunk_lb"
)

func (e OutputSplunkLbType) ToPointer() *OutputSplunkLbType {
	return &e
}

func (e *OutputSplunkLbType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "splunk_lb":
		*e = OutputSplunkLbType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for OutputSplunkLbType: %v", v)
	}
}

type OutputSplunkLb struct {
	// Shared secret token to use when establishing a connection to a Splunk indexer.
	AuthToken *string `json:"authToken,omitempty"`
	// Enter a token directly, or provide a secret referencing a token
	AuthType *OutputSplunkLbAuthenticationMethod `json:"authType,omitempty"`
	// Amount of time (milliseconds) to wait for the connection to establish before retrying
	ConnectionTimeout *int64 `json:"connectionTimeout,omitempty"`
	// Re-resolve any hostnames every this many seconds and pick up destinations from A records.
	DNSResolvePeriodSec *int64 `json:"dnsResolvePeriodSec,omitempty"`
	// Check if indexer is shutting down and stop sending data. This helps minimize data loss during shutdown.
	EnableACK *bool `json:"enableACK,omitempty"`
	// Output metrics in multiple-metric format in a single event. Supported in Splunk 8.0 and above.
	EnableMultiMetrics *bool `json:"enableMultiMetrics,omitempty"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Exclude all IPs of the current host from the list of any resolved hostnames.
	ExcludeSelf *bool `json:"excludeSelf,omitempty"`
	// Set of Splunk indexers to load-balance data to.
	Hosts []OutputSplunkLbHosts `json:"hosts"`
	// Unique ID for this output
	ID *string `json:"id,omitempty"`
	// Automatically discover indexers in indexer clustering environment.
	IndexerDiscovery *bool `json:"indexerDiscovery,omitempty"`
	// List of configurations to set up indexer discovery in Splunk Indexer clustering environment.
	IndexerDiscoveryConfigs *OutputSplunkLbIndexerDiscoveryConfigs `json:"indexerDiscoveryConfigs,omitempty"`
	// How far back in time to keep traffic stats for load balancing purposes.
	LoadBalanceStatsPeriodSec *int64 `json:"loadBalanceStatsPeriodSec,omitempty"`
	// Maximum number of concurrent connections (per worker process). A random set of IPs will be picked on every DNS resolution period. Use 0 for unlimited.
	MaxConcurrentSenders *int64 `json:"maxConcurrentSenders,omitempty"`
	// Maximum number of times healthcheck can fail before we close connection. If set to 0 (disabled), and the connection to Splunk is forcibly closed, some data loss might occur.
	MaxFailedHealthChecks *int64 `json:"maxFailedHealthChecks,omitempty"`
	// The highest S2S protocol version to advertise during handshake.
	MaxS2Sversion *OutputSplunkLbMaxS2SVersion `json:"maxS2Sversion,omitempty"`
	// Specifies how to serialize nested fields into index-time fields.
	NestedFields *OutputSplunkLbNestedFieldSerialization `json:"nestedFields,omitempty"`
	// Whether to block, drop, or queue events when all receivers are exerting backpressure.
	OnBackpressure                 *OutputSplunkLbBackpressureBehavior           `json:"onBackpressure,omitempty"`
	OptionalFieldsInGeneralSection *OutputSplunkLbOptionalFieldsInGeneralSection `json:"optionalFieldsInGeneralSection,omitempty"`
	// Pipeline to process data before sending out to this output.
	Pipeline *string `json:"pipeline,omitempty"`
	// Codec to use to compress the persisted data.
	PqCompress *OutputSplunkLbCompression `json:"pqCompress,omitempty"`
	PqControls *OutputSplunkLbPqControls  `json:"pqControls,omitempty"`
	// The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.).
	PqMaxFileSize *string `json:"pqMaxFileSize,omitempty"`
	// The maximum amount of disk space the queue is allowed to consume. Once reached, the system stops queueing and applies the fallback Queue-full behavior. Enter a numeral with units of KB, MB, etc.
	PqMaxSize *string `json:"pqMaxSize,omitempty"`
	// Whether to block or drop events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
	PqOnBackpressure *OutputSplunkLbQueueFullBehavior `json:"pqOnBackpressure,omitempty"`
	// The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>.
	PqPath *string `json:"pqPath,omitempty"`
	// Toggle this off to forward new events to receiver(s) before queue is flushed. Otherwise, default drain behavior is FIFO (first in, first out).
	PqStrictOrdering *bool `json:"pqStrictOrdering,omitempty"`
	// How long (in milliseconds) each LB endpoint can report blocked before the Destination reports unhealthy, blocking the sender. (Grace period for fluctuations.) Use 0 to disable; max 1 minute.
	SenderUnhealthyTimeAllowance *int64 `json:"senderUnhealthyTimeAllowance,omitempty"`
	// Add tags for filtering and grouping in @{product}.
	Streamtags []string `json:"streamtags,omitempty"`
	// Set of fields to automatically add to events using this output. E.g.: cribl_pipe, c*. Wildcards supported.
	SystemFields []string `json:"systemFields,omitempty"`
	// Select (or create) a stored text secret
	TextSecret *string `json:"textSecret,omitempty"`
	// Rate (in bytes per second) to throttle while writing to an output. Also takes values with multiple-byte units, such as KB, MB, GB, etc. (E.g., 42 MB.) Default value of 0 specifies no throttling.
	ThrottleRatePerSec *string                              `json:"throttleRatePerSec,omitempty"`
	TLS                *OutputSplunkLbTLSSettingsClientSide `json:"tls,omitempty"`
	Type               OutputSplunkLbType                   `json:"type"`
	// Amount of time (milliseconds) to wait for a write to complete before assuming connection is dead
	WriteTimeout *int64 `json:"writeTimeout,omitempty"`
}
