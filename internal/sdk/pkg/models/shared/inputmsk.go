// Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.

package shared

import (
	"encoding/json"
	"fmt"
)

// InputMskAuthenticationMethod - AWS authentication method. Choose Auto to use IAM roles.
type InputMskAuthenticationMethod string

const (
	InputMskAuthenticationMethodSecret InputMskAuthenticationMethod = "secret"
	InputMskAuthenticationMethodManual InputMskAuthenticationMethod = "manual"
)

func (e InputMskAuthenticationMethod) ToPointer() *InputMskAuthenticationMethod {
	return &e
}

func (e *InputMskAuthenticationMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "secret":
		fallthrough
	case "manual":
		*e = InputMskAuthenticationMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for InputMskAuthenticationMethod: %v", v)
	}
}

type InputMskConnections struct {
	// Select a Destination.
	Output string `json:"output"`
	// Select Pipeline or Pack. Optional.
	Pipeline *string `json:"pipeline,omitempty"`
}

// InputMskKafkaSchemaRegistryAuthenticationTLSSettingsClientSideMaximumTLSVersion - Maximum TLS version to use when connecting
type InputMskKafkaSchemaRegistryAuthenticationTLSSettingsClientSideMaximumTLSVersion string

const (
	InputMskKafkaSchemaRegistryAuthenticationTLSSettingsClientSideMaximumTLSVersionTlSv1  InputMskKafkaSchemaRegistryAuthenticationTLSSettingsClientSideMaximumTLSVersion = "TLSv1"
	InputMskKafkaSchemaRegistryAuthenticationTLSSettingsClientSideMaximumTLSVersionTlSv11 InputMskKafkaSchemaRegistryAuthenticationTLSSettingsClientSideMaximumTLSVersion = "TLSv1.1"
	InputMskKafkaSchemaRegistryAuthenticationTLSSettingsClientSideMaximumTLSVersionTlSv12 InputMskKafkaSchemaRegistryAuthenticationTLSSettingsClientSideMaximumTLSVersion = "TLSv1.2"
	InputMskKafkaSchemaRegistryAuthenticationTLSSettingsClientSideMaximumTLSVersionTlSv13 InputMskKafkaSchemaRegistryAuthenticationTLSSettingsClientSideMaximumTLSVersion = "TLSv1.3"
)

func (e InputMskKafkaSchemaRegistryAuthenticationTLSSettingsClientSideMaximumTLSVersion) ToPointer() *InputMskKafkaSchemaRegistryAuthenticationTLSSettingsClientSideMaximumTLSVersion {
	return &e
}

func (e *InputMskKafkaSchemaRegistryAuthenticationTLSSettingsClientSideMaximumTLSVersion) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "TLSv1":
		fallthrough
	case "TLSv1.1":
		fallthrough
	case "TLSv1.2":
		fallthrough
	case "TLSv1.3":
		*e = InputMskKafkaSchemaRegistryAuthenticationTLSSettingsClientSideMaximumTLSVersion(v)
		return nil
	default:
		return fmt.Errorf("invalid value for InputMskKafkaSchemaRegistryAuthenticationTLSSettingsClientSideMaximumTLSVersion: %v", v)
	}
}

// InputMskKafkaSchemaRegistryAuthenticationTLSSettingsClientSideMinimumTLSVersion - Minimum TLS version to use when connecting
type InputMskKafkaSchemaRegistryAuthenticationTLSSettingsClientSideMinimumTLSVersion string

const (
	InputMskKafkaSchemaRegistryAuthenticationTLSSettingsClientSideMinimumTLSVersionTlSv1  InputMskKafkaSchemaRegistryAuthenticationTLSSettingsClientSideMinimumTLSVersion = "TLSv1"
	InputMskKafkaSchemaRegistryAuthenticationTLSSettingsClientSideMinimumTLSVersionTlSv11 InputMskKafkaSchemaRegistryAuthenticationTLSSettingsClientSideMinimumTLSVersion = "TLSv1.1"
	InputMskKafkaSchemaRegistryAuthenticationTLSSettingsClientSideMinimumTLSVersionTlSv12 InputMskKafkaSchemaRegistryAuthenticationTLSSettingsClientSideMinimumTLSVersion = "TLSv1.2"
	InputMskKafkaSchemaRegistryAuthenticationTLSSettingsClientSideMinimumTLSVersionTlSv13 InputMskKafkaSchemaRegistryAuthenticationTLSSettingsClientSideMinimumTLSVersion = "TLSv1.3"
)

func (e InputMskKafkaSchemaRegistryAuthenticationTLSSettingsClientSideMinimumTLSVersion) ToPointer() *InputMskKafkaSchemaRegistryAuthenticationTLSSettingsClientSideMinimumTLSVersion {
	return &e
}

func (e *InputMskKafkaSchemaRegistryAuthenticationTLSSettingsClientSideMinimumTLSVersion) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "TLSv1":
		fallthrough
	case "TLSv1.1":
		fallthrough
	case "TLSv1.2":
		fallthrough
	case "TLSv1.3":
		*e = InputMskKafkaSchemaRegistryAuthenticationTLSSettingsClientSideMinimumTLSVersion(v)
		return nil
	default:
		return fmt.Errorf("invalid value for InputMskKafkaSchemaRegistryAuthenticationTLSSettingsClientSideMinimumTLSVersion: %v", v)
	}
}

type InputMskKafkaSchemaRegistryAuthenticationTLSSettingsClientSide struct {
	// Path on client in which to find CA certificates to verify the server's cert. PEM format. Can reference $ENV_VARS.
	CaPath *string `json:"caPath,omitempty"`
	// Path on client in which to find certificates to use. PEM format. Can reference $ENV_VARS.
	CertPath *string `json:"certPath,omitempty"`
	// The name of the predefined certificate.
	CertificateName *string `json:"certificateName,omitempty"`
	Disabled        *bool   `json:"disabled,omitempty"`
	// Maximum TLS version to use when connecting
	MaxVersion *InputMskKafkaSchemaRegistryAuthenticationTLSSettingsClientSideMaximumTLSVersion `json:"maxVersion,omitempty"`
	// Minimum TLS version to use when connecting
	MinVersion *InputMskKafkaSchemaRegistryAuthenticationTLSSettingsClientSideMinimumTLSVersion `json:"minVersion,omitempty"`
	// Passphrase to use to decrypt private key.
	Passphrase *string `json:"passphrase,omitempty"`
	// Path on client in which to find the private key to use. PEM format. Can reference $ENV_VARS.
	PrivKeyPath *string `json:"privKeyPath,omitempty"`
	// Reject certs that are not authorized by a CA in the CA certificate path, or by another trusted CA (e.g., the system's CA). Defaults to No.
	RejectUnauthorized *bool `json:"rejectUnauthorized,omitempty"`
	// Server name for the SNI (Server Name Indication) TLS extension. It must be a host name, and not an IP address.
	Servername *string `json:"servername,omitempty"`
}

type InputMskKafkaSchemaRegistryAuthentication struct {
	// Enable Schema Registry
	Disabled bool `json:"disabled"`
	// URL for access to the Confluent Schema Registry, i.e: http://localhost:8081
	SchemaRegistryURL *string                                                         `json:"schemaRegistryURL,omitempty"`
	TLS               *InputMskKafkaSchemaRegistryAuthenticationTLSSettingsClientSide `json:"tls,omitempty"`
}

type InputMskMetadata struct {
	// Field name
	Name string `json:"name"`
	// JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
	Value string `json:"value"`
}

// InputMskPqCompression - Codec to use to compress the persisted data.
type InputMskPqCompression string

const (
	InputMskPqCompressionNone InputMskPqCompression = "none"
	InputMskPqCompressionGzip InputMskPqCompression = "gzip"
)

func (e InputMskPqCompression) ToPointer() *InputMskPqCompression {
	return &e
}

func (e *InputMskPqCompression) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "none":
		fallthrough
	case "gzip":
		*e = InputMskPqCompression(v)
		return nil
	default:
		return fmt.Errorf("invalid value for InputMskPqCompression: %v", v)
	}
}

// InputMskPqMode - With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
type InputMskPqMode string

const (
	InputMskPqModeSmart  InputMskPqMode = "smart"
	InputMskPqModeAlways InputMskPqMode = "always"
)

func (e InputMskPqMode) ToPointer() *InputMskPqMode {
	return &e
}

func (e *InputMskPqMode) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "smart":
		fallthrough
	case "always":
		*e = InputMskPqMode(v)
		return nil
	default:
		return fmt.Errorf("invalid value for InputMskPqMode: %v", v)
	}
}

type InputMskPq struct {
	// The number of events to send downstream before committing that Stream has read them.
	CommitFrequency *int64 `json:"commitFrequency,omitempty"`
	// Codec to use to compress the persisted data.
	Compress *InputMskPqCompression `json:"compress,omitempty"`
	// The maximum number of events to hold in memory before writing the events to disk.
	MaxBufferSize *int64 `json:"maxBufferSize,omitempty"`
	// The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.).
	MaxFileSize *string `json:"maxFileSize,omitempty"`
	// The maximum amount of disk space the queue is allowed to consume. Once reached, the system stops queueing and applies the fallback Queue-full behavior. Enter a numeral with units of KB, MB, etc.
	MaxSize *string `json:"maxSize,omitempty"`
	// With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
	Mode *InputMskPqMode `json:"mode,omitempty"`
	// The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>.
	Path *string `json:"path,omitempty"`
}

// InputMskRegion - Region where the MSK cluster is located
type InputMskRegion string

const (
	InputMskRegionUsEast1      InputMskRegion = "us-east-1"
	InputMskRegionUsEast2      InputMskRegion = "us-east-2"
	InputMskRegionUsWest1      InputMskRegion = "us-west-1"
	InputMskRegionUsWest2      InputMskRegion = "us-west-2"
	InputMskRegionAfSouth1     InputMskRegion = "af-south-1"
	InputMskRegionCaCentral1   InputMskRegion = "ca-central-1"
	InputMskRegionEuWest1      InputMskRegion = "eu-west-1"
	InputMskRegionEuCentral1   InputMskRegion = "eu-central-1"
	InputMskRegionEuWest2      InputMskRegion = "eu-west-2"
	InputMskRegionEuSouth1     InputMskRegion = "eu-south-1"
	InputMskRegionEuWest3      InputMskRegion = "eu-west-3"
	InputMskRegionEuNorth1     InputMskRegion = "eu-north-1"
	InputMskRegionApEast1      InputMskRegion = "ap-east-1"
	InputMskRegionApNortheast1 InputMskRegion = "ap-northeast-1"
	InputMskRegionApNortheast2 InputMskRegion = "ap-northeast-2"
	InputMskRegionApSoutheast1 InputMskRegion = "ap-southeast-1"
	InputMskRegionApSoutheast2 InputMskRegion = "ap-southeast-2"
	InputMskRegionApSouth1     InputMskRegion = "ap-south-1"
	InputMskRegionMeSouth1     InputMskRegion = "me-south-1"
	InputMskRegionSaEast1      InputMskRegion = "sa-east-1"
	InputMskRegionUsGovEast1   InputMskRegion = "us-gov-east-1"
	InputMskRegionUsGovWest1   InputMskRegion = "us-gov-west-1"
)

func (e InputMskRegion) ToPointer() *InputMskRegion {
	return &e
}

func (e *InputMskRegion) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "us-east-1":
		fallthrough
	case "us-east-2":
		fallthrough
	case "us-west-1":
		fallthrough
	case "us-west-2":
		fallthrough
	case "af-south-1":
		fallthrough
	case "ca-central-1":
		fallthrough
	case "eu-west-1":
		fallthrough
	case "eu-central-1":
		fallthrough
	case "eu-west-2":
		fallthrough
	case "eu-south-1":
		fallthrough
	case "eu-west-3":
		fallthrough
	case "eu-north-1":
		fallthrough
	case "ap-east-1":
		fallthrough
	case "ap-northeast-1":
		fallthrough
	case "ap-northeast-2":
		fallthrough
	case "ap-southeast-1":
		fallthrough
	case "ap-southeast-2":
		fallthrough
	case "ap-south-1":
		fallthrough
	case "me-south-1":
		fallthrough
	case "sa-east-1":
		fallthrough
	case "us-gov-east-1":
		fallthrough
	case "us-gov-west-1":
		*e = InputMskRegion(v)
		return nil
	default:
		return fmt.Errorf("invalid value for InputMskRegion: %v", v)
	}
}

// InputMskSignatureVersion - Signature version to use for signing MSK cluster requests.
type InputMskSignatureVersion string

const (
	InputMskSignatureVersionV2 InputMskSignatureVersion = "v2"
	InputMskSignatureVersionV4 InputMskSignatureVersion = "v4"
)

func (e InputMskSignatureVersion) ToPointer() *InputMskSignatureVersion {
	return &e
}

func (e *InputMskSignatureVersion) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "v2":
		fallthrough
	case "v4":
		*e = InputMskSignatureVersion(v)
		return nil
	default:
		return fmt.Errorf("invalid value for InputMskSignatureVersion: %v", v)
	}
}

// InputMskTLSSettingsClientSideMaximumTLSVersion - Maximum TLS version to use when connecting
type InputMskTLSSettingsClientSideMaximumTLSVersion string

const (
	InputMskTLSSettingsClientSideMaximumTLSVersionTlSv1  InputMskTLSSettingsClientSideMaximumTLSVersion = "TLSv1"
	InputMskTLSSettingsClientSideMaximumTLSVersionTlSv11 InputMskTLSSettingsClientSideMaximumTLSVersion = "TLSv1.1"
	InputMskTLSSettingsClientSideMaximumTLSVersionTlSv12 InputMskTLSSettingsClientSideMaximumTLSVersion = "TLSv1.2"
	InputMskTLSSettingsClientSideMaximumTLSVersionTlSv13 InputMskTLSSettingsClientSideMaximumTLSVersion = "TLSv1.3"
)

func (e InputMskTLSSettingsClientSideMaximumTLSVersion) ToPointer() *InputMskTLSSettingsClientSideMaximumTLSVersion {
	return &e
}

func (e *InputMskTLSSettingsClientSideMaximumTLSVersion) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "TLSv1":
		fallthrough
	case "TLSv1.1":
		fallthrough
	case "TLSv1.2":
		fallthrough
	case "TLSv1.3":
		*e = InputMskTLSSettingsClientSideMaximumTLSVersion(v)
		return nil
	default:
		return fmt.Errorf("invalid value for InputMskTLSSettingsClientSideMaximumTLSVersion: %v", v)
	}
}

// InputMskTLSSettingsClientSideMinimumTLSVersion - Minimum TLS version to use when connecting
type InputMskTLSSettingsClientSideMinimumTLSVersion string

const (
	InputMskTLSSettingsClientSideMinimumTLSVersionTlSv1  InputMskTLSSettingsClientSideMinimumTLSVersion = "TLSv1"
	InputMskTLSSettingsClientSideMinimumTLSVersionTlSv11 InputMskTLSSettingsClientSideMinimumTLSVersion = "TLSv1.1"
	InputMskTLSSettingsClientSideMinimumTLSVersionTlSv12 InputMskTLSSettingsClientSideMinimumTLSVersion = "TLSv1.2"
	InputMskTLSSettingsClientSideMinimumTLSVersionTlSv13 InputMskTLSSettingsClientSideMinimumTLSVersion = "TLSv1.3"
)

func (e InputMskTLSSettingsClientSideMinimumTLSVersion) ToPointer() *InputMskTLSSettingsClientSideMinimumTLSVersion {
	return &e
}

func (e *InputMskTLSSettingsClientSideMinimumTLSVersion) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "TLSv1":
		fallthrough
	case "TLSv1.1":
		fallthrough
	case "TLSv1.2":
		fallthrough
	case "TLSv1.3":
		*e = InputMskTLSSettingsClientSideMinimumTLSVersion(v)
		return nil
	default:
		return fmt.Errorf("invalid value for InputMskTLSSettingsClientSideMinimumTLSVersion: %v", v)
	}
}

type InputMskTLSSettingsClientSide struct {
	// Path on client in which to find CA certificates to verify the server's cert. PEM format. Can reference $ENV_VARS.
	CaPath *string `json:"caPath,omitempty"`
	// Path on client in which to find certificates to use. PEM format. Can reference $ENV_VARS.
	CertPath *string `json:"certPath,omitempty"`
	// The name of the predefined certificate.
	CertificateName *string `json:"certificateName,omitempty"`
	Disabled        *bool   `json:"disabled,omitempty"`
	// Maximum TLS version to use when connecting
	MaxVersion *InputMskTLSSettingsClientSideMaximumTLSVersion `json:"maxVersion,omitempty"`
	// Minimum TLS version to use when connecting
	MinVersion *InputMskTLSSettingsClientSideMinimumTLSVersion `json:"minVersion,omitempty"`
	// Passphrase to use to decrypt private key.
	Passphrase *string `json:"passphrase,omitempty"`
	// Path on client in which to find the private key to use. PEM format. Can reference $ENV_VARS.
	PrivKeyPath *string `json:"privKeyPath,omitempty"`
	// Reject certs that are not authorized by a CA in the CA certificate path, or by another trusted CA (e.g., the system's CA). Defaults to No.
	RejectUnauthorized *bool `json:"rejectUnauthorized,omitempty"`
	// Server name for the SNI (Server Name Indication) TLS extension. It must be a host name, and not an IP address.
	Servername *string `json:"servername,omitempty"`
}

type InputMskType string

const (
	InputMskTypeMsk InputMskType = "msk"
)

func (e InputMskType) ToPointer() *InputMskType {
	return &e
}

func (e *InputMskType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "msk":
		*e = InputMskType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for InputMskType: %v", v)
	}
}

type InputMskAuthentication string

const (
	InputMskAuthenticationAwsAPIKey    InputMskAuthentication = "awsApiKey"
	InputMskAuthenticationAwsSecretKey InputMskAuthentication = "awsSecretKey"
)

func (e InputMskAuthentication) ToPointer() *InputMskAuthentication {
	return &e
}

func (e *InputMskAuthentication) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "awsApiKey":
		fallthrough
	case "awsSecretKey":
		*e = InputMskAuthentication(v)
		return nil
	default:
		return fmt.Errorf("invalid value for InputMskAuthentication: %v", v)
	}
}

type InputMsk struct {
	// Amazon Resource Name (ARN) of the role to assume
	AssumeRoleArn *string `json:"assumeRoleArn,omitempty"`
	// External ID to use when assuming role
	AssumeRoleExternalID *string `json:"assumeRoleExternalId,omitempty"`
	// Maximum time to wait for Kafka to respond to an authentication request
	AuthenticationTimeout *int64 `json:"authenticationTimeout,omitempty"`
	// How often to commit offsets. If both this and Offset commit threshold are set, @{product} commits offsets when either condition is met. If both are empty, @{product} commits offsets after each batch.
	AutoCommitInterval *int64 `json:"autoCommitInterval,omitempty"`
	// How many events are needed to trigger an offset commit. If both this and Offset commit interval are set, @{product} commits offsets when either condition is met. If both are empty, @{product} commits offsets after each batch.
	AutoCommitThreshold *int64 `json:"autoCommitThreshold,omitempty"`
	// Access key
	AwsAPIKey *string `json:"awsApiKey,omitempty"`
	// AWS authentication method. Choose Auto to use IAM roles.
	AwsAuthenticationMethod InputMskAuthenticationMethod `json:"awsAuthenticationMethod"`
	// Select (or create) a stored secret that references your access key and secret key.
	AwsSecret *string `json:"awsSecret,omitempty"`
	// Secret key
	AwsSecretKey *string `json:"awsSecretKey,omitempty"`
	// Enter each Kafka broker you want to use. Specify hostname and port, e.g., mykafkabroker:9092, or just hostname, in which case @{product} will assign port 9092.
	Brokers []string `json:"brokers"`
	// Maximum time to wait for a connection to complete successfully
	ConnectionTimeout *int64 `json:"connectionTimeout,omitempty"`
	// Direct connections to Destinations, optionally via a Pipeline or a Pack.
	Connections []InputMskConnections `json:"connections,omitempty"`
	// Enable/disable this input
	Disabled *bool `json:"disabled,omitempty"`
	// Use Assume Role credentials to access MSK
	EnableAssumeRole *bool `json:"enableAssumeRole,omitempty"`
	// MSK cluster service endpoint. If empty, defaults to AWS' Region-specific endpoint. Otherwise, it must point to MSK cluster-compatible endpoint.
	Endpoint *string `json:"endpoint,omitempty"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Leave toggled to 'Yes' if you want the Source, upon first subscribing to a topic, to read starting with the earliest available message
	FromBeginning *bool `json:"fromBeginning,omitempty"`
	// Specifies the consumer group to which this instance belongs. Defaults to 'Cribl'.
	GroupID *string `json:"groupId,omitempty"`
	//       Expected time between heartbeats to the consumer coordinator when using Kafka's group management facilities.
	//       Value must be lower than sessionTimeout, and typically should not exceed 1/3 of the sessionTimeout value.
	//       See details [here](https://kafka.apache.org/documentation/#consumerconfigs_heartbeat.interval.ms).
	HeartbeatInterval *int64 `json:"heartbeatInterval,omitempty"`
	// Unique ID for this input
	ID                  *string                                    `json:"id,omitempty"`
	KafkaSchemaRegistry *InputMskKafkaSchemaRegistryAuthentication `json:"kafkaSchemaRegistry,omitempty"`
	// Maximum number of bytes that Kafka will return per fetch request. Defaults to 10485760 (10 MB).
	MaxBytes *int64 `json:"maxBytes,omitempty"`
	// Maximum amount of data that Kafka will return per partition, per fetch request. Must equal or exceed the maximum message size (maxBytesPerPartition) that Kafka is configured to allow. Otherwise, @{product} can get stuck trying to retrieve messages. Defaults to 1048576 (1 MB).
	MaxBytesPerPartition *int64 `json:"maxBytesPerPartition,omitempty"`
	// If messages are failing, you can set the maximum number of retries as high as 100 to prevent loss of data.
	MaxRetries *int64 `json:"maxRetries,omitempty"`
	// Fields to add to events from this input.
	Metadata []InputMskMetadata `json:"metadata,omitempty"`
	// Pipeline to process data from this Source before sending it through the Routes.
	Pipeline *string     `json:"pipeline,omitempty"`
	Pq       *InputMskPq `json:"pq,omitempty"`
	// For details on Persistent Queues, see: [https://docs.cribl.io/stream/persistent-queues](https://docs.cribl.io/stream/persistent-queues)
	PqEnabled *bool `json:"pqEnabled,omitempty"`
	// Specifies a time window during which @{product} can reauthenticate if needed. Creates the window measuring backwards from the moment when credentials are set to expire.
	ReauthenticationThreshold *int64 `json:"reauthenticationThreshold,omitempty"`
	//       Maximum allowed time for each worker to join the group after a rebalance has begun.
	//       If the timeout is exceeded, the coordinator broker will remove the worker from the group.
	//       See details [here](https://kafka.apache.org/documentation/#connectconfigs_rebalance.timeout.ms).
	RebalanceTimeout *int64 `json:"rebalanceTimeout,omitempty"`
	// Region where the MSK cluster is located
	Region InputMskRegion `json:"region"`
	// Whether to reject certificates that cannot be verified against a valid CA (e.g., self-signed certificates).
	RejectUnauthorized *bool `json:"rejectUnauthorized,omitempty"`
	// Maximum time to wait for Kafka to respond to a request
	RequestTimeout *int64 `json:"requestTimeout,omitempty"`
	// Whether to reuse connections between requests, which can improve performance.
	ReuseConnections *bool `json:"reuseConnections,omitempty"`
	// Select whether to send data to Routes, or directly to Destinations.
	// - true
	SendToRoutes *bool `json:"sendToRoutes,omitempty"`
	//       Timeout used to detect client failures when using Kafka's group management facilities.
	//       If the client sends the broker no heartbeats before this timeout expires,
	//       the broker will remove this client from the group, and will initiate a rebalance.
	//       Value must be between the broker's configured group.min.session.timeout.ms and group.max.session.timeout.ms.
	//       See details [here](https://kafka.apache.org/documentation/#consumerconfigs_session.timeout.ms).
	SessionTimeout *int64 `json:"sessionTimeout,omitempty"`
	// Signature version to use for signing MSK cluster requests.
	SignatureVersion *InputMskSignatureVersion `json:"signatureVersion,omitempty"`
	// Add tags for filtering and grouping in @{product}.
	Streamtags []string                       `json:"streamtags,omitempty"`
	TLS        *InputMskTLSSettingsClientSide `json:"tls,omitempty"`
	// Topic to subscribe to. Warning: To optimize performance, Cribl suggests subscribing each Kafka Source to only a single topic.
	Topics      []string                `json:"topics"`
	Type        *InputMskType           `json:"type,omitempty"`
	XMetasecret *InputMskAuthentication `json:"x-metasecret,omitempty"`
}
