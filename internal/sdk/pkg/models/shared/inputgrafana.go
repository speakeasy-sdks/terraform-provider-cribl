// Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.

package shared

import (
	"bytes"
	"encoding/json"
	"errors"
	"fmt"
)

type InputGrafana2Connections struct {
	// Select a Destination.
	Output string `json:"output"`
	// Select Pipeline or Pack. Optional.
	Pipeline *string `json:"pipeline,omitempty"`
}

// InputGrafana2LokiAuthAuthenticationType - Loki logs authentication type
type InputGrafana2LokiAuthAuthenticationType string

const (
	InputGrafana2LokiAuthAuthenticationTypeOauth             InputGrafana2LokiAuthAuthenticationType = "oauth"
	InputGrafana2LokiAuthAuthenticationTypeBasic             InputGrafana2LokiAuthAuthenticationType = "basic"
	InputGrafana2LokiAuthAuthenticationTypeCredentialsSecret InputGrafana2LokiAuthAuthenticationType = "credentialsSecret"
	InputGrafana2LokiAuthAuthenticationTypeToken             InputGrafana2LokiAuthAuthenticationType = "token"
	InputGrafana2LokiAuthAuthenticationTypeTextSecret        InputGrafana2LokiAuthAuthenticationType = "textSecret"
)

func (e InputGrafana2LokiAuthAuthenticationType) ToPointer() *InputGrafana2LokiAuthAuthenticationType {
	return &e
}

func (e *InputGrafana2LokiAuthAuthenticationType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "oauth":
		fallthrough
	case "basic":
		fallthrough
	case "credentialsSecret":
		fallthrough
	case "token":
		fallthrough
	case "textSecret":
		*e = InputGrafana2LokiAuthAuthenticationType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for InputGrafana2LokiAuthAuthenticationType: %v", v)
	}
}

type InputGrafana2LokiAuthOauthHeaders struct {
	// OAuth header name
	Name string `json:"name"`
	// OAuth header value
	Value string `json:"value"`
}

type InputGrafana2LokiAuthOauthParams struct {
	// OAuth parameter name
	Name string `json:"name"`
	// OAuth parameter value
	Value string `json:"value"`
}

type InputGrafana2LokiAuth struct {
	// JavaScript expression to compute the Authorization header value to pass in requests. The value `${token}` is used to reference the token obtained from authentication, e.g.: `Bearer ${token}`.
	AuthHeaderExpr *string `json:"authHeaderExpr,omitempty"`
	// Loki logs authentication type
	AuthType *InputGrafana2LokiAuthAuthenticationType `json:"authType,omitempty"`
	// Select (or create) a secret that references your credentials
	CredentialsSecret *string `json:"credentialsSecret,omitempty"`
	// URL for OAuth
	LoginURL *string `json:"loginUrl,omitempty"`
	// Additional headers to send in the OAuth login request. @{product} will automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
	OauthHeaders []InputGrafana2LokiAuthOauthHeaders `json:"oauthHeaders,omitempty"`
	// Additional parameters to send in the OAuth login request. @{product} will combine the secret with these parameters, and will send the URL-encoded result in a POST request to the endpoint specified in the 'Login URL'. We'll automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
	OauthParams []InputGrafana2LokiAuthOauthParams `json:"oauthParams,omitempty"`
	// Password for Basic authentication
	Password *string `json:"password,omitempty"`
	// Secret parameter value to pass in request body
	Secret *string `json:"secret,omitempty"`
	// Secret parameter name to pass in request body
	SecretParamName *string `json:"secretParamName,omitempty"`
	Spacer          *string `json:"spacer,omitempty"`
	// Select (or create) a stored text secret
	TextSecret *string `json:"textSecret,omitempty"`
	// Bearer token to include in the authorization header
	Token *string `json:"token,omitempty"`
	// Name of the auth token attribute in the OAuth response. Can be top-level (e.g., 'token'); or nested, using a period (e.g., 'data.token').
	TokenAttributeName *string `json:"tokenAttributeName,omitempty"`
	// How often the OAuth token should be refreshed.
	TokenTimeoutSecs *int64 `json:"tokenTimeoutSecs,omitempty"`
	// Username for Basic authentication
	Username *string `json:"username,omitempty"`
}

type InputGrafana2Metadata struct {
	// Field name
	Name string `json:"name"`
	// JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
	Value string `json:"value"`
}

// InputGrafana2PqCompression - Codec to use to compress the persisted data.
type InputGrafana2PqCompression string

const (
	InputGrafana2PqCompressionNone InputGrafana2PqCompression = "none"
	InputGrafana2PqCompressionGzip InputGrafana2PqCompression = "gzip"
)

func (e InputGrafana2PqCompression) ToPointer() *InputGrafana2PqCompression {
	return &e
}

func (e *InputGrafana2PqCompression) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "none":
		fallthrough
	case "gzip":
		*e = InputGrafana2PqCompression(v)
		return nil
	default:
		return fmt.Errorf("invalid value for InputGrafana2PqCompression: %v", v)
	}
}

// InputGrafana2PqMode - With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
type InputGrafana2PqMode string

const (
	InputGrafana2PqModeSmart  InputGrafana2PqMode = "smart"
	InputGrafana2PqModeAlways InputGrafana2PqMode = "always"
)

func (e InputGrafana2PqMode) ToPointer() *InputGrafana2PqMode {
	return &e
}

func (e *InputGrafana2PqMode) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "smart":
		fallthrough
	case "always":
		*e = InputGrafana2PqMode(v)
		return nil
	default:
		return fmt.Errorf("invalid value for InputGrafana2PqMode: %v", v)
	}
}

type InputGrafana2Pq struct {
	// The number of events to send downstream before committing that Stream has read them.
	CommitFrequency *int64 `json:"commitFrequency,omitempty"`
	// Codec to use to compress the persisted data.
	Compress *InputGrafana2PqCompression `json:"compress,omitempty"`
	// The maximum number of events to hold in memory before writing the events to disk.
	MaxBufferSize *int64 `json:"maxBufferSize,omitempty"`
	// The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.).
	MaxFileSize *string `json:"maxFileSize,omitempty"`
	// The maximum amount of disk space the queue is allowed to consume. Once reached, the system stops queueing and applies the fallback Queue-full behavior. Enter a numeral with units of KB, MB, etc.
	MaxSize *string `json:"maxSize,omitempty"`
	// With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
	Mode *InputGrafana2PqMode `json:"mode,omitempty"`
	// The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>.
	Path *string `json:"path,omitempty"`
}

// InputGrafana2PrometheusAuthAuthenticationType - Remote Write authentication type
type InputGrafana2PrometheusAuthAuthenticationType string

const (
	InputGrafana2PrometheusAuthAuthenticationTypeOauth             InputGrafana2PrometheusAuthAuthenticationType = "oauth"
	InputGrafana2PrometheusAuthAuthenticationTypeBasic             InputGrafana2PrometheusAuthAuthenticationType = "basic"
	InputGrafana2PrometheusAuthAuthenticationTypeCredentialsSecret InputGrafana2PrometheusAuthAuthenticationType = "credentialsSecret"
	InputGrafana2PrometheusAuthAuthenticationTypeToken             InputGrafana2PrometheusAuthAuthenticationType = "token"
	InputGrafana2PrometheusAuthAuthenticationTypeTextSecret        InputGrafana2PrometheusAuthAuthenticationType = "textSecret"
)

func (e InputGrafana2PrometheusAuthAuthenticationType) ToPointer() *InputGrafana2PrometheusAuthAuthenticationType {
	return &e
}

func (e *InputGrafana2PrometheusAuthAuthenticationType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "oauth":
		fallthrough
	case "basic":
		fallthrough
	case "credentialsSecret":
		fallthrough
	case "token":
		fallthrough
	case "textSecret":
		*e = InputGrafana2PrometheusAuthAuthenticationType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for InputGrafana2PrometheusAuthAuthenticationType: %v", v)
	}
}

type InputGrafana2PrometheusAuthOauthHeaders struct {
	// OAuth header name
	Name string `json:"name"`
	// OAuth header value
	Value string `json:"value"`
}

type InputGrafana2PrometheusAuthOauthParams struct {
	// OAuth parameter name
	Name string `json:"name"`
	// OAuth parameter value
	Value string `json:"value"`
}

type InputGrafana2PrometheusAuth struct {
	// JavaScript expression to compute the Authorization header value to pass in requests. The value `${token}` is used to reference the token obtained from authentication, e.g.: `Bearer ${token}`.
	AuthHeaderExpr *string `json:"authHeaderExpr,omitempty"`
	// Remote Write authentication type
	AuthType *InputGrafana2PrometheusAuthAuthenticationType `json:"authType,omitempty"`
	// Select (or create) a secret that references your credentials
	CredentialsSecret *string `json:"credentialsSecret,omitempty"`
	// URL for OAuth
	LoginURL *string `json:"loginUrl,omitempty"`
	// Additional headers to send in the OAuth login request. @{product} will automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
	OauthHeaders []InputGrafana2PrometheusAuthOauthHeaders `json:"oauthHeaders,omitempty"`
	// Additional parameters to send in the OAuth login request. @{product} will combine the secret with these parameters, and will send the URL-encoded result in a POST request to the endpoint specified in the 'Login URL'. We'll automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
	OauthParams []InputGrafana2PrometheusAuthOauthParams `json:"oauthParams,omitempty"`
	// Password for Basic authentication
	Password *string `json:"password,omitempty"`
	// Secret parameter value to pass in request body
	Secret *string `json:"secret,omitempty"`
	// Secret parameter name to pass in request body
	SecretParamName *string `json:"secretParamName,omitempty"`
	Spacer          *string `json:"spacer,omitempty"`
	// Select (or create) a stored text secret
	TextSecret *string `json:"textSecret,omitempty"`
	// Bearer token to include in the authorization header
	Token *string `json:"token,omitempty"`
	// Name of the auth token attribute in the OAuth response. Can be top-level (e.g., 'token'); or nested, using a period (e.g., 'data.token').
	TokenAttributeName *string `json:"tokenAttributeName,omitempty"`
	// How often the OAuth token should be refreshed.
	TokenTimeoutSecs *int64 `json:"tokenTimeoutSecs,omitempty"`
	// Username for Basic authentication
	Username *string `json:"username,omitempty"`
}

// InputGrafana2TLSSettingsServerSideMaximumTLSVersion - Maximum TLS version to accept from connections.
type InputGrafana2TLSSettingsServerSideMaximumTLSVersion string

const (
	InputGrafana2TLSSettingsServerSideMaximumTLSVersionTlSv1  InputGrafana2TLSSettingsServerSideMaximumTLSVersion = "TLSv1"
	InputGrafana2TLSSettingsServerSideMaximumTLSVersionTlSv11 InputGrafana2TLSSettingsServerSideMaximumTLSVersion = "TLSv1.1"
	InputGrafana2TLSSettingsServerSideMaximumTLSVersionTlSv12 InputGrafana2TLSSettingsServerSideMaximumTLSVersion = "TLSv1.2"
	InputGrafana2TLSSettingsServerSideMaximumTLSVersionTlSv13 InputGrafana2TLSSettingsServerSideMaximumTLSVersion = "TLSv1.3"
)

func (e InputGrafana2TLSSettingsServerSideMaximumTLSVersion) ToPointer() *InputGrafana2TLSSettingsServerSideMaximumTLSVersion {
	return &e
}

func (e *InputGrafana2TLSSettingsServerSideMaximumTLSVersion) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "TLSv1":
		fallthrough
	case "TLSv1.1":
		fallthrough
	case "TLSv1.2":
		fallthrough
	case "TLSv1.3":
		*e = InputGrafana2TLSSettingsServerSideMaximumTLSVersion(v)
		return nil
	default:
		return fmt.Errorf("invalid value for InputGrafana2TLSSettingsServerSideMaximumTLSVersion: %v", v)
	}
}

// InputGrafana2TLSSettingsServerSideMinimumTLSVersion - Minimum TLS version to accept from connections.
type InputGrafana2TLSSettingsServerSideMinimumTLSVersion string

const (
	InputGrafana2TLSSettingsServerSideMinimumTLSVersionTlSv1  InputGrafana2TLSSettingsServerSideMinimumTLSVersion = "TLSv1"
	InputGrafana2TLSSettingsServerSideMinimumTLSVersionTlSv11 InputGrafana2TLSSettingsServerSideMinimumTLSVersion = "TLSv1.1"
	InputGrafana2TLSSettingsServerSideMinimumTLSVersionTlSv12 InputGrafana2TLSSettingsServerSideMinimumTLSVersion = "TLSv1.2"
	InputGrafana2TLSSettingsServerSideMinimumTLSVersionTlSv13 InputGrafana2TLSSettingsServerSideMinimumTLSVersion = "TLSv1.3"
)

func (e InputGrafana2TLSSettingsServerSideMinimumTLSVersion) ToPointer() *InputGrafana2TLSSettingsServerSideMinimumTLSVersion {
	return &e
}

func (e *InputGrafana2TLSSettingsServerSideMinimumTLSVersion) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "TLSv1":
		fallthrough
	case "TLSv1.1":
		fallthrough
	case "TLSv1.2":
		fallthrough
	case "TLSv1.3":
		*e = InputGrafana2TLSSettingsServerSideMinimumTLSVersion(v)
		return nil
	default:
		return fmt.Errorf("invalid value for InputGrafana2TLSSettingsServerSideMinimumTLSVersion: %v", v)
	}
}

type InputGrafana2TLSSettingsServerSide struct {
	// Path on server containing CA certificates to use. PEM format. Can reference $ENV_VARS.
	CaPath *string `json:"caPath,omitempty"`
	// Path on server containing certificates to use. PEM format. Can reference $ENV_VARS.
	CertPath *string `json:"certPath,omitempty"`
	// The name of the predefined certificate.
	CertificateName *string     `json:"certificateName,omitempty"`
	CommonNameRegex interface{} `json:"commonNameRegex,omitempty"`
	Disabled        *bool       `json:"disabled,omitempty"`
	// Maximum TLS version to accept from connections.
	MaxVersion *InputGrafana2TLSSettingsServerSideMaximumTLSVersion `json:"maxVersion,omitempty"`
	// Minimum TLS version to accept from connections.
	MinVersion *InputGrafana2TLSSettingsServerSideMinimumTLSVersion `json:"minVersion,omitempty"`
	// Passphrase to use to decrypt private key.
	Passphrase *string `json:"passphrase,omitempty"`
	// Path on server containing the private key to use. PEM format. Can reference $ENV_VARS.
	PrivKeyPath        *string     `json:"privKeyPath,omitempty"`
	RejectUnauthorized interface{} `json:"rejectUnauthorized,omitempty"`
	// Whether to require clients to present their certificates. Used to perform client authentication using SSL certs.
	RequestCert *bool `json:"requestCert,omitempty"`
}

type InputGrafana2Type string

const (
	InputGrafana2TypeGrafana InputGrafana2Type = "grafana"
)

func (e InputGrafana2Type) ToPointer() *InputGrafana2Type {
	return &e
}

func (e *InputGrafana2Type) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "grafana":
		*e = InputGrafana2Type(v)
		return nil
	default:
		return fmt.Errorf("invalid value for InputGrafana2Type: %v", v)
	}
}

type InputGrafana2 struct {
	// How often request activity is logged at the `info` level. A value of 1 would log every request, 10 every 10th request, etc.
	ActivityLogSampleRate *int64 `json:"activityLogSampleRate,omitempty"`
	// Toggle this to Yes to add request headers to events, in the __headers field.
	CaptureHeaders *bool `json:"captureHeaders,omitempty"`
	// Direct connections to Destinations, optionally via a Pipeline or a Pack.
	Connections []InputGrafana2Connections `json:"connections,omitempty"`
	// Enable/disable this input
	Disabled *bool `json:"disabled,omitempty"`
	// Enable if the connection is proxied by a device that supports Proxy Protocol V1 or V2.
	EnableProxyHeader *bool `json:"enableProxyHeader,omitempty"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Address to bind on. Defaults to 0.0.0.0 (all addresses).
	Host string `json:"host"`
	// Unique ID for this input
	ID *string `json:"id,omitempty"`
	// Maximum time to wait for additional data, after the last response was sent, before closing a socket connection. This can be very useful when Grafana Agent remote write's request frequency is high so, reusing connections, would help mitigating the cost of creating a new connection per request. Note that Grafana Agent's embedded Prometheus would attempt to keep connections open for up to 5 minutes.
	KeepAliveTimeout *int64 `json:"keepAliveTimeout,omitempty"`
	// Absolute path on which to listen for Loki logs requests. Defaults to /loki/api/v1/push, which will (in this example) expand as: 'http://<your‑upstream‑URL>:<your‑port>/loki/api/v1/push'.
	LokiAPI  string                 `json:"lokiAPI"`
	LokiAuth *InputGrafana2LokiAuth `json:"lokiAuth,omitempty"`
	// Maximum number of active requests per Worker Process. Use 0 for unlimited.
	MaxActiveReq *int64 `json:"maxActiveReq,omitempty"`
	// Fields to add to events from this input.
	Metadata []InputGrafana2Metadata `json:"metadata,omitempty"`
	// Pipeline to process data from this Source before sending it through the Routes.
	Pipeline *string `json:"pipeline,omitempty"`
	// Port to listen on.
	Port int64            `json:"port"`
	Pq   *InputGrafana2Pq `json:"pq,omitempty"`
	// For details on Persistent Queues, see: [https://docs.cribl.io/stream/persistent-queues](https://docs.cribl.io/stream/persistent-queues)
	PqEnabled *bool `json:"pqEnabled,omitempty"`
	// Absolute path on which to listen for Grafana Agent's Remote Write requests. Defaults to /api/prom/push, which will expand as: http://<your‑upstream‑URL>:<your‑port>/api/prom/push.
	PrometheusAPI  *string                      `json:"prometheusAPI,omitempty"`
	PrometheusAuth *InputGrafana2PrometheusAuth `json:"prometheusAuth,omitempty"`
	// How long to wait for an incoming request to complete before aborting it. Use 0 to disable.
	RequestTimeout *int64 `json:"requestTimeout,omitempty"`
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `json:"sendToRoutes,omitempty"`
	// How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0.
	SocketTimeout *int64 `json:"socketTimeout,omitempty"`
	// Add tags for filtering and grouping in @{product}.
	Streamtags []string                            `json:"streamtags,omitempty"`
	TLS        *InputGrafana2TLSSettingsServerSide `json:"tls,omitempty"`
	Type       *InputGrafana2Type                  `json:"type,omitempty"`
}

type InputGrafana1Connections struct {
	// Select a Destination.
	Output string `json:"output"`
	// Select Pipeline or Pack. Optional.
	Pipeline *string `json:"pipeline,omitempty"`
}

// InputGrafana1LokiAuthAuthenticationType - Loki logs authentication type
type InputGrafana1LokiAuthAuthenticationType string

const (
	InputGrafana1LokiAuthAuthenticationTypeOauth             InputGrafana1LokiAuthAuthenticationType = "oauth"
	InputGrafana1LokiAuthAuthenticationTypeBasic             InputGrafana1LokiAuthAuthenticationType = "basic"
	InputGrafana1LokiAuthAuthenticationTypeCredentialsSecret InputGrafana1LokiAuthAuthenticationType = "credentialsSecret"
	InputGrafana1LokiAuthAuthenticationTypeToken             InputGrafana1LokiAuthAuthenticationType = "token"
	InputGrafana1LokiAuthAuthenticationTypeTextSecret        InputGrafana1LokiAuthAuthenticationType = "textSecret"
)

func (e InputGrafana1LokiAuthAuthenticationType) ToPointer() *InputGrafana1LokiAuthAuthenticationType {
	return &e
}

func (e *InputGrafana1LokiAuthAuthenticationType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "oauth":
		fallthrough
	case "basic":
		fallthrough
	case "credentialsSecret":
		fallthrough
	case "token":
		fallthrough
	case "textSecret":
		*e = InputGrafana1LokiAuthAuthenticationType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for InputGrafana1LokiAuthAuthenticationType: %v", v)
	}
}

type InputGrafana1LokiAuthOauthHeaders struct {
	// OAuth header name
	Name string `json:"name"`
	// OAuth header value
	Value string `json:"value"`
}

type InputGrafana1LokiAuthOauthParams struct {
	// OAuth parameter name
	Name string `json:"name"`
	// OAuth parameter value
	Value string `json:"value"`
}

type InputGrafana1LokiAuth struct {
	// JavaScript expression to compute the Authorization header value to pass in requests. The value `${token}` is used to reference the token obtained from authentication, e.g.: `Bearer ${token}`.
	AuthHeaderExpr *string `json:"authHeaderExpr,omitempty"`
	// Loki logs authentication type
	AuthType *InputGrafana1LokiAuthAuthenticationType `json:"authType,omitempty"`
	// Select (or create) a secret that references your credentials
	CredentialsSecret *string `json:"credentialsSecret,omitempty"`
	// URL for OAuth
	LoginURL *string `json:"loginUrl,omitempty"`
	// Additional headers to send in the OAuth login request. @{product} will automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
	OauthHeaders []InputGrafana1LokiAuthOauthHeaders `json:"oauthHeaders,omitempty"`
	// Additional parameters to send in the OAuth login request. @{product} will combine the secret with these parameters, and will send the URL-encoded result in a POST request to the endpoint specified in the 'Login URL'. We'll automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
	OauthParams []InputGrafana1LokiAuthOauthParams `json:"oauthParams,omitempty"`
	// Password for Basic authentication
	Password *string `json:"password,omitempty"`
	// Secret parameter value to pass in request body
	Secret *string `json:"secret,omitempty"`
	// Secret parameter name to pass in request body
	SecretParamName *string `json:"secretParamName,omitempty"`
	Spacer          *string `json:"spacer,omitempty"`
	// Select (or create) a stored text secret
	TextSecret *string `json:"textSecret,omitempty"`
	// Bearer token to include in the authorization header
	Token *string `json:"token,omitempty"`
	// Name of the auth token attribute in the OAuth response. Can be top-level (e.g., 'token'); or nested, using a period (e.g., 'data.token').
	TokenAttributeName *string `json:"tokenAttributeName,omitempty"`
	// How often the OAuth token should be refreshed.
	TokenTimeoutSecs *int64 `json:"tokenTimeoutSecs,omitempty"`
	// Username for Basic authentication
	Username *string `json:"username,omitempty"`
}

type InputGrafana1Metadata struct {
	// Field name
	Name string `json:"name"`
	// JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
	Value string `json:"value"`
}

// InputGrafana1PqCompression - Codec to use to compress the persisted data.
type InputGrafana1PqCompression string

const (
	InputGrafana1PqCompressionNone InputGrafana1PqCompression = "none"
	InputGrafana1PqCompressionGzip InputGrafana1PqCompression = "gzip"
)

func (e InputGrafana1PqCompression) ToPointer() *InputGrafana1PqCompression {
	return &e
}

func (e *InputGrafana1PqCompression) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "none":
		fallthrough
	case "gzip":
		*e = InputGrafana1PqCompression(v)
		return nil
	default:
		return fmt.Errorf("invalid value for InputGrafana1PqCompression: %v", v)
	}
}

// InputGrafana1PqMode - With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
type InputGrafana1PqMode string

const (
	InputGrafana1PqModeSmart  InputGrafana1PqMode = "smart"
	InputGrafana1PqModeAlways InputGrafana1PqMode = "always"
)

func (e InputGrafana1PqMode) ToPointer() *InputGrafana1PqMode {
	return &e
}

func (e *InputGrafana1PqMode) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "smart":
		fallthrough
	case "always":
		*e = InputGrafana1PqMode(v)
		return nil
	default:
		return fmt.Errorf("invalid value for InputGrafana1PqMode: %v", v)
	}
}

type InputGrafana1Pq struct {
	// The number of events to send downstream before committing that Stream has read them.
	CommitFrequency *int64 `json:"commitFrequency,omitempty"`
	// Codec to use to compress the persisted data.
	Compress *InputGrafana1PqCompression `json:"compress,omitempty"`
	// The maximum number of events to hold in memory before writing the events to disk.
	MaxBufferSize *int64 `json:"maxBufferSize,omitempty"`
	// The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.).
	MaxFileSize *string `json:"maxFileSize,omitempty"`
	// The maximum amount of disk space the queue is allowed to consume. Once reached, the system stops queueing and applies the fallback Queue-full behavior. Enter a numeral with units of KB, MB, etc.
	MaxSize *string `json:"maxSize,omitempty"`
	// With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
	Mode *InputGrafana1PqMode `json:"mode,omitempty"`
	// The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>.
	Path *string `json:"path,omitempty"`
}

// InputGrafana1PrometheusAuthAuthenticationType - Remote Write authentication type
type InputGrafana1PrometheusAuthAuthenticationType string

const (
	InputGrafana1PrometheusAuthAuthenticationTypeOauth             InputGrafana1PrometheusAuthAuthenticationType = "oauth"
	InputGrafana1PrometheusAuthAuthenticationTypeBasic             InputGrafana1PrometheusAuthAuthenticationType = "basic"
	InputGrafana1PrometheusAuthAuthenticationTypeCredentialsSecret InputGrafana1PrometheusAuthAuthenticationType = "credentialsSecret"
	InputGrafana1PrometheusAuthAuthenticationTypeToken             InputGrafana1PrometheusAuthAuthenticationType = "token"
	InputGrafana1PrometheusAuthAuthenticationTypeTextSecret        InputGrafana1PrometheusAuthAuthenticationType = "textSecret"
)

func (e InputGrafana1PrometheusAuthAuthenticationType) ToPointer() *InputGrafana1PrometheusAuthAuthenticationType {
	return &e
}

func (e *InputGrafana1PrometheusAuthAuthenticationType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "oauth":
		fallthrough
	case "basic":
		fallthrough
	case "credentialsSecret":
		fallthrough
	case "token":
		fallthrough
	case "textSecret":
		*e = InputGrafana1PrometheusAuthAuthenticationType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for InputGrafana1PrometheusAuthAuthenticationType: %v", v)
	}
}

type InputGrafana1PrometheusAuthOauthHeaders struct {
	// OAuth header name
	Name string `json:"name"`
	// OAuth header value
	Value string `json:"value"`
}

type InputGrafana1PrometheusAuthOauthParams struct {
	// OAuth parameter name
	Name string `json:"name"`
	// OAuth parameter value
	Value string `json:"value"`
}

type InputGrafana1PrometheusAuth struct {
	// JavaScript expression to compute the Authorization header value to pass in requests. The value `${token}` is used to reference the token obtained from authentication, e.g.: `Bearer ${token}`.
	AuthHeaderExpr *string `json:"authHeaderExpr,omitempty"`
	// Remote Write authentication type
	AuthType *InputGrafana1PrometheusAuthAuthenticationType `json:"authType,omitempty"`
	// Select (or create) a secret that references your credentials
	CredentialsSecret *string `json:"credentialsSecret,omitempty"`
	// URL for OAuth
	LoginURL *string `json:"loginUrl,omitempty"`
	// Additional headers to send in the OAuth login request. @{product} will automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
	OauthHeaders []InputGrafana1PrometheusAuthOauthHeaders `json:"oauthHeaders,omitempty"`
	// Additional parameters to send in the OAuth login request. @{product} will combine the secret with these parameters, and will send the URL-encoded result in a POST request to the endpoint specified in the 'Login URL'. We'll automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
	OauthParams []InputGrafana1PrometheusAuthOauthParams `json:"oauthParams,omitempty"`
	// Password for Basic authentication
	Password *string `json:"password,omitempty"`
	// Secret parameter value to pass in request body
	Secret *string `json:"secret,omitempty"`
	// Secret parameter name to pass in request body
	SecretParamName *string `json:"secretParamName,omitempty"`
	Spacer          *string `json:"spacer,omitempty"`
	// Select (or create) a stored text secret
	TextSecret *string `json:"textSecret,omitempty"`
	// Bearer token to include in the authorization header
	Token *string `json:"token,omitempty"`
	// Name of the auth token attribute in the OAuth response. Can be top-level (e.g., 'token'); or nested, using a period (e.g., 'data.token').
	TokenAttributeName *string `json:"tokenAttributeName,omitempty"`
	// How often the OAuth token should be refreshed.
	TokenTimeoutSecs *int64 `json:"tokenTimeoutSecs,omitempty"`
	// Username for Basic authentication
	Username *string `json:"username,omitempty"`
}

// InputGrafana1TLSSettingsServerSideMaximumTLSVersion - Maximum TLS version to accept from connections.
type InputGrafana1TLSSettingsServerSideMaximumTLSVersion string

const (
	InputGrafana1TLSSettingsServerSideMaximumTLSVersionTlSv1  InputGrafana1TLSSettingsServerSideMaximumTLSVersion = "TLSv1"
	InputGrafana1TLSSettingsServerSideMaximumTLSVersionTlSv11 InputGrafana1TLSSettingsServerSideMaximumTLSVersion = "TLSv1.1"
	InputGrafana1TLSSettingsServerSideMaximumTLSVersionTlSv12 InputGrafana1TLSSettingsServerSideMaximumTLSVersion = "TLSv1.2"
	InputGrafana1TLSSettingsServerSideMaximumTLSVersionTlSv13 InputGrafana1TLSSettingsServerSideMaximumTLSVersion = "TLSv1.3"
)

func (e InputGrafana1TLSSettingsServerSideMaximumTLSVersion) ToPointer() *InputGrafana1TLSSettingsServerSideMaximumTLSVersion {
	return &e
}

func (e *InputGrafana1TLSSettingsServerSideMaximumTLSVersion) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "TLSv1":
		fallthrough
	case "TLSv1.1":
		fallthrough
	case "TLSv1.2":
		fallthrough
	case "TLSv1.3":
		*e = InputGrafana1TLSSettingsServerSideMaximumTLSVersion(v)
		return nil
	default:
		return fmt.Errorf("invalid value for InputGrafana1TLSSettingsServerSideMaximumTLSVersion: %v", v)
	}
}

// InputGrafana1TLSSettingsServerSideMinimumTLSVersion - Minimum TLS version to accept from connections.
type InputGrafana1TLSSettingsServerSideMinimumTLSVersion string

const (
	InputGrafana1TLSSettingsServerSideMinimumTLSVersionTlSv1  InputGrafana1TLSSettingsServerSideMinimumTLSVersion = "TLSv1"
	InputGrafana1TLSSettingsServerSideMinimumTLSVersionTlSv11 InputGrafana1TLSSettingsServerSideMinimumTLSVersion = "TLSv1.1"
	InputGrafana1TLSSettingsServerSideMinimumTLSVersionTlSv12 InputGrafana1TLSSettingsServerSideMinimumTLSVersion = "TLSv1.2"
	InputGrafana1TLSSettingsServerSideMinimumTLSVersionTlSv13 InputGrafana1TLSSettingsServerSideMinimumTLSVersion = "TLSv1.3"
)

func (e InputGrafana1TLSSettingsServerSideMinimumTLSVersion) ToPointer() *InputGrafana1TLSSettingsServerSideMinimumTLSVersion {
	return &e
}

func (e *InputGrafana1TLSSettingsServerSideMinimumTLSVersion) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "TLSv1":
		fallthrough
	case "TLSv1.1":
		fallthrough
	case "TLSv1.2":
		fallthrough
	case "TLSv1.3":
		*e = InputGrafana1TLSSettingsServerSideMinimumTLSVersion(v)
		return nil
	default:
		return fmt.Errorf("invalid value for InputGrafana1TLSSettingsServerSideMinimumTLSVersion: %v", v)
	}
}

type InputGrafana1TLSSettingsServerSide struct {
	// Path on server containing CA certificates to use. PEM format. Can reference $ENV_VARS.
	CaPath *string `json:"caPath,omitempty"`
	// Path on server containing certificates to use. PEM format. Can reference $ENV_VARS.
	CertPath *string `json:"certPath,omitempty"`
	// The name of the predefined certificate.
	CertificateName *string     `json:"certificateName,omitempty"`
	CommonNameRegex interface{} `json:"commonNameRegex,omitempty"`
	Disabled        *bool       `json:"disabled,omitempty"`
	// Maximum TLS version to accept from connections.
	MaxVersion *InputGrafana1TLSSettingsServerSideMaximumTLSVersion `json:"maxVersion,omitempty"`
	// Minimum TLS version to accept from connections.
	MinVersion *InputGrafana1TLSSettingsServerSideMinimumTLSVersion `json:"minVersion,omitempty"`
	// Passphrase to use to decrypt private key.
	Passphrase *string `json:"passphrase,omitempty"`
	// Path on server containing the private key to use. PEM format. Can reference $ENV_VARS.
	PrivKeyPath        *string     `json:"privKeyPath,omitempty"`
	RejectUnauthorized interface{} `json:"rejectUnauthorized,omitempty"`
	// Whether to require clients to present their certificates. Used to perform client authentication using SSL certs.
	RequestCert *bool `json:"requestCert,omitempty"`
}

type InputGrafana1Type string

const (
	InputGrafana1TypeGrafana InputGrafana1Type = "grafana"
)

func (e InputGrafana1Type) ToPointer() *InputGrafana1Type {
	return &e
}

func (e *InputGrafana1Type) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "grafana":
		*e = InputGrafana1Type(v)
		return nil
	default:
		return fmt.Errorf("invalid value for InputGrafana1Type: %v", v)
	}
}

type InputGrafana1 struct {
	// How often request activity is logged at the `info` level. A value of 1 would log every request, 10 every 10th request, etc.
	ActivityLogSampleRate *int64 `json:"activityLogSampleRate,omitempty"`
	// Toggle this to Yes to add request headers to events, in the __headers field.
	CaptureHeaders *bool `json:"captureHeaders,omitempty"`
	// Direct connections to Destinations, optionally via a Pipeline or a Pack.
	Connections []InputGrafana1Connections `json:"connections,omitempty"`
	// Enable/disable this input
	Disabled *bool `json:"disabled,omitempty"`
	// Enable if the connection is proxied by a device that supports Proxy Protocol V1 or V2.
	EnableProxyHeader *bool `json:"enableProxyHeader,omitempty"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Address to bind on. Defaults to 0.0.0.0 (all addresses).
	Host string `json:"host"`
	// Unique ID for this input
	ID *string `json:"id,omitempty"`
	// Maximum time to wait for additional data, after the last response was sent, before closing a socket connection. This can be very useful when Grafana Agent remote write's request frequency is high so, reusing connections, would help mitigating the cost of creating a new connection per request. Note that Grafana Agent's embedded Prometheus would attempt to keep connections open for up to 5 minutes.
	KeepAliveTimeout *int64 `json:"keepAliveTimeout,omitempty"`
	// Absolute path on which to listen for Loki logs requests. Defaults to /loki/api/v1/push, which will (in this example) expand as: 'http://<your‑upstream‑URL>:<your‑port>/loki/api/v1/push'.
	LokiAPI  *string                `json:"lokiAPI,omitempty"`
	LokiAuth *InputGrafana1LokiAuth `json:"lokiAuth,omitempty"`
	// Maximum number of active requests per Worker Process. Use 0 for unlimited.
	MaxActiveReq *int64 `json:"maxActiveReq,omitempty"`
	// Fields to add to events from this input.
	Metadata []InputGrafana1Metadata `json:"metadata,omitempty"`
	// Pipeline to process data from this Source before sending it through the Routes.
	Pipeline *string `json:"pipeline,omitempty"`
	// Port to listen on.
	Port int64            `json:"port"`
	Pq   *InputGrafana1Pq `json:"pq,omitempty"`
	// For details on Persistent Queues, see: [https://docs.cribl.io/stream/persistent-queues](https://docs.cribl.io/stream/persistent-queues)
	PqEnabled *bool `json:"pqEnabled,omitempty"`
	// Absolute path on which to listen for Grafana Agent's Remote Write requests. Defaults to /api/prom/push, which will expand as: http://<your‑upstream‑URL>:<your‑port>/api/prom/push.
	PrometheusAPI  string                       `json:"prometheusAPI"`
	PrometheusAuth *InputGrafana1PrometheusAuth `json:"prometheusAuth,omitempty"`
	// How long to wait for an incoming request to complete before aborting it. Use 0 to disable.
	RequestTimeout *int64 `json:"requestTimeout,omitempty"`
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `json:"sendToRoutes,omitempty"`
	// How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0.
	SocketTimeout *int64 `json:"socketTimeout,omitempty"`
	// Add tags for filtering and grouping in @{product}.
	Streamtags []string                            `json:"streamtags,omitempty"`
	TLS        *InputGrafana1TLSSettingsServerSide `json:"tls,omitempty"`
	Type       *InputGrafana1Type                  `json:"type,omitempty"`
}

type InputGrafanaType string

const (
	InputGrafanaTypeInputGrafana1 InputGrafanaType = "InputGrafana_1"
	InputGrafanaTypeInputGrafana2 InputGrafanaType = "InputGrafana_2"
)

type InputGrafana struct {
	InputGrafana1 *InputGrafana1
	InputGrafana2 *InputGrafana2

	Type InputGrafanaType
}

func CreateInputGrafanaInputGrafana1(inputGrafana1 InputGrafana1) InputGrafana {
	typ := InputGrafanaTypeInputGrafana1

	return InputGrafana{
		InputGrafana1: &inputGrafana1,
		Type:          typ,
	}
}

func CreateInputGrafanaInputGrafana2(inputGrafana2 InputGrafana2) InputGrafana {
	typ := InputGrafanaTypeInputGrafana2

	return InputGrafana{
		InputGrafana2: &inputGrafana2,
		Type:          typ,
	}
}

func (u *InputGrafana) UnmarshalJSON(data []byte) error {
	var d *json.Decoder

	inputGrafana1 := new(InputGrafana1)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&inputGrafana1); err == nil {
		u.InputGrafana1 = inputGrafana1
		u.Type = InputGrafanaTypeInputGrafana1
		return nil
	}

	inputGrafana2 := new(InputGrafana2)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&inputGrafana2); err == nil {
		u.InputGrafana2 = inputGrafana2
		u.Type = InputGrafanaTypeInputGrafana2
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u InputGrafana) MarshalJSON() ([]byte, error) {
	if u.InputGrafana1 != nil {
		return json.Marshal(u.InputGrafana1)
	}

	if u.InputGrafana2 != nil {
		return json.Marshal(u.InputGrafana2)
	}

	return nil, nil
}
